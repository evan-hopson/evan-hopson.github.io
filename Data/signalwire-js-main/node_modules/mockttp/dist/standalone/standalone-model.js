"use strict";
/**
 * @module Internal
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const graphql_1 = require("graphql");
const graphql_subscriptions_1 = require("graphql-subscriptions");
const mock_rule_1 = require("../rules/mock-rule");
const REQUEST_INITIATED_TOPIC = 'request-initiated';
const REQUEST_RECEIVED_TOPIC = 'request-received';
const RESPONSE_COMPLETED_TOPIC = 'response-completed';
const REQUEST_ABORTED_TOPIC = 'request-aborted';
const TLS_CLIENT_ERROR_TOPIC = 'tls-client-error';
function astToObject(ast) {
    return _.zipObject(ast.fields.map((f) => f.name.value), ast.fields.map((f) => parseAnyAst(f.value)));
}
function parseAnyAst(ast) {
    switch (ast.kind) {
        case graphql_1.Kind.OBJECT:
            return astToObject(ast);
        case graphql_1.Kind.LIST:
            return ast.values.map(parseAnyAst);
        case graphql_1.Kind.BOOLEAN:
        case graphql_1.Kind.ENUM:
        case graphql_1.Kind.FLOAT:
        case graphql_1.Kind.INT:
        case graphql_1.Kind.STRING:
            return ast.value;
        case graphql_1.Kind.NULL:
            return null;
        case graphql_1.Kind.VARIABLE:
            throw new Error("No idea what parsing a 'variable' means");
    }
}
function buildMockedEndpointData(endpoint) {
    return __awaiter(this, void 0, void 0, function* () {
        return {
            id: endpoint.id,
            seenRequests: yield endpoint.getSeenRequests()
        };
    });
}
const ScalarResolvers = {
    RequestMatcher: new graphql_1.GraphQLScalarType({
        name: 'RequestMatcher',
        description: 'Matcher for requests',
        serialize: (value) => {
            throw new Error('Matchers are input only values');
        },
        parseValue: (v) => v,
        parseLiteral(ast) {
            if (ast.kind === graphql_1.Kind.OBJECT) {
                return astToObject(ast);
            }
            else
                return null;
        }
    }),
    RequestHandler: new graphql_1.GraphQLScalarType({
        name: 'RequestHandler',
        description: 'Handler for requests',
        serialize: (value) => {
            throw new Error('Handlers are input only values');
        },
        parseValue: (v) => v,
        parseLiteral(ast) {
            if (ast.kind === graphql_1.Kind.OBJECT) {
                return astToObject(ast);
            }
            else
                return null;
        }
    }),
    RuleCompletionChecker: new graphql_1.GraphQLScalarType({
        name: 'RuleCompletionChecker',
        description: 'Completion checkers for requests',
        serialize: (value) => {
            throw new Error('Completion checkers are input only values');
        },
        parseValue: (v) => v,
        parseLiteral(ast) {
            if (ast.kind === graphql_1.Kind.OBJECT) {
                return astToObject(ast);
            }
            else
                return null;
        }
    }),
    Json: new graphql_1.GraphQLScalarType({
        name: 'Json',
        description: 'A JSON entity, serialized as a simple JSON string',
        serialize: (value) => JSON.stringify(value),
        parseValue: (input) => JSON.parse(input),
        parseLiteral: parseAnyAst
    }),
    Any: new graphql_1.GraphQLScalarType({
        name: 'Any',
        description: 'Wildcard Anything! Here be dragons',
        serialize: (value) => JSON.stringify(value),
        parseValue: (input) => JSON.parse(input),
        parseLiteral: parseAnyAst
    }),
    Buffer: new graphql_1.GraphQLScalarType({
        name: 'Buffer',
        description: 'A buffer',
        serialize: (value) => {
            return value.toString('base64');
        },
        parseValue: (input) => {
            return Buffer.from(input, 'base64');
        },
        parseLiteral: parseAnyAst
    })
};
function buildStandaloneModel(mockServer, stream) {
    const pubsub = new graphql_subscriptions_1.PubSub();
    mockServer.on('request-initiated', (request) => {
        pubsub.publish(REQUEST_INITIATED_TOPIC, {
            requestInitiated: request
        });
    });
    mockServer.on('request', (request) => {
        pubsub.publish(REQUEST_RECEIVED_TOPIC, {
            requestReceived: request
        });
    });
    mockServer.on('response', (response) => {
        pubsub.publish(RESPONSE_COMPLETED_TOPIC, {
            responseCompleted: response
        });
    });
    mockServer.on('abort', (request) => {
        pubsub.publish(REQUEST_ABORTED_TOPIC, {
            requestAborted: request
        });
    });
    mockServer.on('tlsClientError', (request) => {
        pubsub.publish(TLS_CLIENT_ERROR_TOPIC, {
            failedTlsRequest: request
        });
    });
    return Object.assign({ Query: {
            mockedEndpoints: () => {
                return Promise.all(mockServer.mockedEndpoints.map(buildMockedEndpointData));
            },
            mockedEndpoint: (__, { id }) => {
                let endpoint = _.find(mockServer.mockedEndpoints, (endpoint) => {
                    return endpoint.id === id;
                });
                if (!endpoint)
                    return null;
                return buildMockedEndpointData(endpoint);
            }
        }, Mutation: {
            addRule: (__, { input }) => __awaiter(this, void 0, void 0, function* () {
                return mockServer.addRule(mock_rule_1.deserializeRuleData(input, stream));
            }),
            addRules: (__, { input }) => __awaiter(this, void 0, void 0, function* () {
                return mockServer.addRules(...input.map((rule) => mock_rule_1.deserializeRuleData(rule, stream)));
            }),
            setRules: (__, { input }) => __awaiter(this, void 0, void 0, function* () {
                return mockServer.setRules(...input.map((rule) => mock_rule_1.deserializeRuleData(rule, stream)));
            }),
            reset: () => {
                mockServer.reset();
                return true;
            }
        }, Subscription: {
            requestInitiated: {
                subscribe: () => pubsub.asyncIterator(REQUEST_INITIATED_TOPIC)
            },
            requestReceived: {
                subscribe: () => pubsub.asyncIterator(REQUEST_RECEIVED_TOPIC)
            },
            responseCompleted: {
                subscribe: () => pubsub.asyncIterator(RESPONSE_COMPLETED_TOPIC)
            },
            requestAborted: {
                subscribe: () => pubsub.asyncIterator(REQUEST_ABORTED_TOPIC)
            },
            failedTlsRequest: {
                subscribe: () => pubsub.asyncIterator(TLS_CLIENT_ERROR_TOPIC)
            }
        }, Request: {
            body: (request) => {
                return request.body.buffer;
            }
        }, Response: {
            body: (response) => {
                return response.body.buffer;
            }
        } }, ScalarResolvers);
}
exports.buildStandaloneModel = buildStandaloneModel;
//# sourceMappingURL=standalone-model.js.map