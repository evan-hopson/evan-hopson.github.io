"use strict";
/**
 * @module Mockttp
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="../../custom-typings/asynciterator.d.ts" />
const path = require("path");
const fs = require("../util/fs");
const _ = require("lodash");
const express = require("express");
const cors = require("cors");
const corsGate = require("cors-gate");
const bodyParser = require("body-parser");
const ws = require("ws");
const apollo_server_express_1 = require("apollo-server-express");
const graphql_1 = require("graphql");
const graphql_tools_1 = require("graphql-tools");
const subscriptions_transport_ws_1 = require("subscriptions-transport-ws");
const connectWebSocketStream = require("websocket-stream");
const DuplexPair = require("native-duplexpair");
const destroyable_server_1 = require("../util/destroyable-server");
const mockttp_server_1 = require("../server/mockttp-server");
const standalone_model_1 = require("./standalone-model");
const types_1 = require("../types");
class MockttpStandalone {
    constructor(options = {}) {
        this.app = express();
        this.server = null;
        this.mockServers = [];
        this.routers = {};
        this.subscriptionServers = {};
        this.streamServers = {};
        this.debug = options.debug || false;
        if (this.debug)
            console.log('Standalone server started in debug mode');
        this.app.use(cors(options.corsOptions));
        if (options.corsOptions && options.corsOptions.strict) {
            this.app.use(corsGate({
                strict: true,
                allowSafe: false,
                origin: '' // No origin - we accept *no* same-origin requests
            }));
        }
        this.app.use(bodyParser.json({ limit: '50mb' }));
        this.app.post('/start', (req, res) => __awaiter(this, void 0, void 0, function* () {
            if (this.debug)
                console.log('Standalone starting mock server on port', req.query.port);
            try {
                const port = req.query.port
                    ? JSON.parse(req.query.port)
                    : undefined;
                const mockServerOptions = _.defaults({}, req.body, options.serverDefaults);
                if (_.isNumber(port) && this.routers[port] != null) {
                    res.status(409).json({
                        error: `Cannot start: mock server is already running on port ${port}`
                    });
                    return;
                }
                const { mockPort, mockServer } = yield this.startMockServer(mockServerOptions, port);
                const config = {
                    port: mockPort,
                    mockRoot: mockServer.url
                };
                res.json(config);
            }
            catch (e) {
                res.status(500).json({ error: `Failed to start server: ${e.message || e}` });
            }
        }));
        // Dynamically route to admin servers ourselves, so we can easily add/remove
        // servers as we see fit later on.
        this.app.use('/server/:port/', (req, res, next) => {
            const serverPort = Number(req.params.port);
            const serverRouter = this.routers[serverPort];
            if (!serverRouter) {
                res.status(404).send('Unknown mock server');
                console.error(`Request for unknown mock server port: ${req.params.port}`);
                return;
            }
            serverRouter(req, res, next);
        });
    }
    loadSchema(schemaFilename, mockServer, stream) {
        return fs.readFile(path.join(__dirname, schemaFilename), 'utf8')
            .then((schemaString) => graphql_tools_1.makeExecutableSchema({
            typeDefs: schemaString,
            resolvers: standalone_model_1.buildStandaloneModel(mockServer, stream)
        }));
    }
    start(listenOptions = types_1.DEFAULT_STANDALONE_PORT) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.server)
                throw new Error('Standalone server already running');
            yield new Promise((resolve, reject) => {
                this.server = destroyable_server_1.destroyable(this.app.listen(listenOptions, resolve));
                this.server.on('upgrade', (req, socket, head) => {
                    var _a;
                    let isSubscriptionRequest = req.url.match(/^\/server\/(\d+)\/subscription$/);
                    let isStreamRequest = req.url.match(/^\/server\/(\d+)\/stream$/);
                    let isMatch = isSubscriptionRequest || isStreamRequest;
                    if (isMatch) {
                        let port = parseInt(isMatch[1], 10);
                        let wsServer = isSubscriptionRequest ? (_a = this.subscriptionServers[port]) === null || _a === void 0 ? void 0 : _a.wsServer :
                            this.streamServers[port];
                        if (wsServer) {
                            wsServer.handleUpgrade(req, socket, head, (ws) => {
                                wsServer.emit('connection', ws, req);
                            });
                        }
                        else {
                            console.warn(`Websocket request for unrecognized mock server: ${port}`);
                            socket.destroy();
                        }
                    }
                    else {
                        console.warn(`Unrecognized websocket request for ${req.url}`);
                        socket.destroy();
                    }
                });
            });
        });
    }
    startMockServer(options, portConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const mockServer = new mockttp_server_1.default(_.defaults(options, {
                // Use debug mode if the client requests it, or if the standalone has it set
                debug: this.debug
            }));
            yield mockServer.start(portConfig);
            this.mockServers.push(mockServer);
            const mockPort = mockServer.port;
            const mockServerRouter = express.Router();
            this.routers[mockPort] = mockServerRouter;
            mockServerRouter.post('/stop', (req, res) => __awaiter(this, void 0, void 0, function* () {
                yield mockServer.stop();
                this.mockServers = _.reject(this.mockServers, mockServer);
                delete this.routers[mockPort];
                delete this.subscriptionServers[mockPort];
                this.streamServers[mockPort].close();
                this.streamServers[mockPort].emit('close');
                delete this.streamServers[mockPort];
                res.status(200).send(JSON.stringify({
                    success: true
                }));
            }));
            // A pair of sockets, representing the 2-way connection between the server & WSs.
            // All websocket messages are written to wsSocket, and then read from serverSocket
            // All server messages are written to serverSocket, and then read from wsSocket and sent
            const { socket1: wsSocket, socket2: serverSocket } = new DuplexPair();
            if (this.debug) {
                serverSocket.on('data', (d) => {
                    console.debug('Streaming data to WS clients:', d.toString());
                });
                wsSocket.on('data', (d) => {
                    console.debug('Streaming data from WS clients:', d.toString());
                });
            }
            this.streamServers[mockPort] = new ws.Server({ noServer: true });
            this.streamServers[mockPort].on('connection', (ws) => {
                let newClientStream = connectWebSocketStream(ws);
                wsSocket.pipe(newClientStream).pipe(wsSocket, { end: false });
            });
            this.streamServers[mockPort].on('close', () => {
                wsSocket.end();
                serverSocket.end();
            });
            const schema = yield this.loadSchema('schema.gql', mockServer, serverSocket);
            this.subscriptionServers[mockPort] = subscriptions_transport_ws_1.SubscriptionServer.create({
                schema, execute: graphql_1.execute, subscribe: graphql_1.subscribe
            }, {
                noServer: true
            });
            mockServerRouter.use(apollo_server_express_1.graphqlExpress({ schema }));
            return {
                mockPort,
                mockServer
            };
        });
    }
    stop() {
        if (!this.server)
            return Promise.resolve();
        return Promise.all([
            this.server.destroy(),
        ].concat(this.mockServers.map((s) => s.stop()))).then(() => {
            this.server = null;
        });
    }
    get activeServerPorts() {
        return this.mockServers.map(s => s.port);
    }
}
exports.MockttpStandalone = MockttpStandalone;
//# sourceMappingURL=mockttp-standalone.js.map