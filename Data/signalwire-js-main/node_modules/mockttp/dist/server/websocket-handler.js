"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const WebSocket = require("ws");
const url = require("url");
// Pile of hacks to blindly forward all WS connections upstream untouched
class WebSocketHandler {
    constructor(debug) {
        this.debug = debug;
        this.wsServer = new WebSocket.Server({ noServer: true });
        this.wsServer.on('connection', (ws) => {
            if (this.debug)
                console.log('Successfully proxying websocket streams');
            this.pipeWebSocket(ws, ws.upstreamSocket);
            this.pipeWebSocket(ws.upstreamSocket, ws);
        });
    }
    handleUpgrade(req, socket, head) {
        return __awaiter(this, void 0, void 0, function* () {
            let { protocol: requestedProtocol, hostname, port, path } = url.parse(req.url);
            if (this.debug)
                console.log(`Handling upgrade for ${req.url}`);
            const transparentProxy = !hostname;
            if (transparentProxy) {
                const hostHeader = req.headers.host;
                [hostname, port] = hostHeader.split(':');
                // upstreamEncryption is set in http-combo-server, for requests that have explicitly
                // CONNECTed upstream (which may then up/downgrade from the current encryption).
                let protocol;
                if (socket.upstreamEncryption !== undefined) {
                    protocol = socket.upstreamEncryption ? 'wss' : 'ws';
                }
                else {
                    protocol = req.connection.encrypted ? 'wss' : 'ws';
                }
                this.connectUpstream(`${protocol}://${hostname}${port ? ':' + port : ''}${path}`, req, socket, head);
            }
            else {
                // Connect directly according to the specified URL
                const protocol = requestedProtocol.replace('http', 'ws');
                this.connectUpstream(`${protocol}//${hostname}${port ? ':' + port : ''}${path}`, req, socket, head);
            }
        });
    }
    connectUpstream(url, req, socket, head) {
        if (this.debug)
            console.log(`Connecting to upstream websocket at ${url}`);
        const upstreamSocket = new WebSocket(url);
        upstreamSocket.once('open', () => {
            this.wsServer.handleUpgrade(req, socket, head, (ws) => {
                ws.upstreamSocket = upstreamSocket;
                this.wsServer.emit('connection', ws);
            });
        });
        upstreamSocket.once('error', (e) => console.warn(e));
    }
    pipeWebSocket(inSocket, outSocket) {
        const onPipeFailed = (op) => (err) => {
            if (!err)
                return;
            inSocket.close();
            console.error(`Websocket ${op} failed`, err);
        };
        inSocket.on('message', (msg) => outSocket.send(msg, onPipeFailed('message')));
        inSocket.on('close', (num, reason) => {
            if (num >= 1000 && num <= 1004) {
                if (this.debug)
                    console.log('Successfully proxying websocket streams');
                outSocket.close(num, reason);
            }
            else {
                // Unspecified or invalid error
                outSocket.close();
            }
        });
        inSocket.on('ping', (data) => outSocket.ping(data, undefined, onPipeFailed('ping')));
        inSocket.on('pong', (data) => outSocket.pong(data, undefined, onPipeFailed('pong')));
    }
}
exports.WebSocketHandler = WebSocketHandler;
//# sourceMappingURL=websocket-handler.js.map