"use strict";
/**
 * @module Mockttp
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const url = require("url");
const events_1 = require("events");
const portfinder = require("portfinder");
const express = require("express");
const uuid = require("uuid/v4");
const cors = require("cors");
const now = require("performance-now");
const _ = require("lodash");
const mockttp_1 = require("../mockttp");
const mock_rule_1 = require("../rules/mock-rule");
const mocked_endpoint_1 = require("./mocked-endpoint");
const http_combo_server_1 = require("./http-combo-server");
const promise_1 = require("../util/promise");
const request_utils_1 = require("../util/request-utils");
const websocket_handler_1 = require("./websocket-handler");
const handlers_1 = require("../rules/handlers");
/**
 * A in-process Mockttp implementation. This starts servers on the local machine in the
 * current process, and exposes methods to directly manage them.
 *
 * This class does not work in browsers, as it expects to be able to start HTTP servers.
 */
class MockttpServer extends mockttp_1.AbstractMockttp {
    constructor(options = {}) {
        super(options);
        this.rules = [];
        this.setRules = (...ruleData) => {
            this.rules.forEach(r => r.dispose());
            this.rules = ruleData.map((ruleDatum) => new mock_rule_1.MockRule(ruleDatum));
            return Promise.resolve(this.rules.map(r => new mocked_endpoint_1.MockedEndpoint(r)));
        };
        this.addRules = (...ruleData) => {
            return Promise.resolve(ruleData.map((ruleDatum) => {
                const rule = new mock_rule_1.MockRule(ruleDatum);
                this.rules.push(rule);
                return new mocked_endpoint_1.MockedEndpoint(rule);
            }));
        };
        this.isComplete = (rule, matchingRules) => {
            const isDefinitelyComplete = rule.isComplete();
            if (isDefinitelyComplete !== null) {
                return isDefinitelyComplete;
            }
            else if (matchingRules[matchingRules.length - 1] === rule) {
                return false;
            }
            else {
                return rule.requests.length !== 0;
            }
        };
        this.initialDebugSetting = this.debug;
        this.httpsOptions = options.https;
        this.eventEmitter = new events_1.EventEmitter();
        this.app = express();
        this.app.disable('x-powered-by');
        if (this.cors) {
            if (this.debug)
                console.log('Enabling CORS');
            this.app.use(cors({
                methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS']
            }));
        }
        this.app.use(request_utils_1.parseBody);
        this.app.use((req, res, next) => {
            // Make req.url always absolute, if it isn't already, using the host header.
            // It might not be if this is a direct request, or if it's being transparently proxied.
            // The 2nd argument is ignored if req.url is already absolute.
            if (!request_utils_1.isAbsoluteUrl(req.url)) {
                req.url = new url.URL(req.url, `${req.protocol}://${req.headers['host']}`).toString();
            }
            next();
        });
        this.app.use(this.handleRequest.bind(this));
    }
    start(portParam = { startPort: 8000, endPort: 65535 }) {
        return __awaiter(this, void 0, void 0, function* () {
            const port = _.isNumber(portParam)
                ? portParam
                : yield portfinder.getPortPromise({
                    port: portParam.startPort,
                    stopPort: portParam.endPort
                });
            if (this.debug)
                console.log(`Starting mock server on port ${port}`);
            this.server = yield http_combo_server_1.createComboServer({
                debug: this.debug,
                https: this.httpsOptions
            }, this.app, this.announceTlsErrorAsync.bind(this));
            this.server.listen(port);
            // Handle websocket connections too (ignore for now, just forward on)
            const webSocketHander = new websocket_handler_1.WebSocketHandler(this.debug);
            this.server.on('upgrade', webSocketHander.handleUpgrade.bind(webSocketHander));
            return new Promise((resolve, reject) => {
                this.server.on('listening', resolve);
                this.server.on('error', (e) => {
                    // Although we try to pick a free port, we may have race conditions, if something else
                    // takes the same port at the same time. If you haven't explicitly picked a port, and
                    // we do have a collision, simply try again.
                    if (e.code === 'EADDRINUSE' && !portParam) {
                        if (this.debug)
                            console.log('Address in use, retrying...');
                        this.server.destroy(); // Don't bother waiting for this, it can stop on its own time
                        resolve(this.start());
                    }
                    else {
                        reject(e);
                    }
                });
            });
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.debug)
                console.log(`Stopping server at ${this.url}`);
            if (this.server)
                yield this.server.destroy();
            this.reset();
        });
    }
    enableDebug() {
        this.debug = true;
    }
    reset() {
        this.rules.forEach(r => r.dispose());
        this.rules = [];
        this.debug = this.initialDebugSetting;
    }
    get mockedEndpoints() {
        return this.rules.map((rule) => new mocked_endpoint_1.MockedEndpoint(rule));
    }
    get address() {
        if (!this.server)
            throw new Error('Cannot get address before server is started');
        return this.server.address();
    }
    get url() {
        if (!this.server)
            throw new Error('Cannot get url before server is started');
        if (this.httpsOptions) {
            return "https://localhost:" + this.port;
        }
        else {
            return "http://localhost:" + this.port;
        }
    }
    get port() {
        if (!this.server)
            throw new Error('Cannot get port before server is started');
        return this.address.port;
    }
    on(event, callback) {
        this.eventEmitter.on(event, callback);
        return Promise.resolve();
    }
    announceInitialRequestAsync(request) {
        setImmediate(() => {
            const initiatedReq = request_utils_1.buildInitiatedRequest(request);
            this.eventEmitter.emit('request-initiated', Object.assign(initiatedReq, {
                timingEvents: _.clone(initiatedReq.timingEvents),
                tags: _.clone(initiatedReq.tags)
            }));
        });
    }
    announceCompletedRequestAsync(request) {
        setImmediate(() => {
            request_utils_1.waitForCompletedRequest(request)
                .then((completedReq) => {
                this.eventEmitter.emit('request', Object.assign(completedReq, {
                    timingEvents: _.clone(completedReq.timingEvents),
                    tags: _.clone(completedReq.tags)
                }));
            })
                .catch(console.error);
        });
    }
    announceResponseAsync(response) {
        setImmediate(() => {
            request_utils_1.waitForCompletedResponse(response)
                .then((res) => {
                this.eventEmitter.emit('response', Object.assign(res, {
                    timingEvents: _.clone(res.timingEvents),
                    tags: _.clone(res.tags)
                }));
            })
                .catch(console.error);
        });
    }
    announceAbortAsync(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = request_utils_1.buildAbortedRequest(request);
            this.eventEmitter.emit('abort', Object.assign(req, {
                timingEvents: _.clone(req.timingEvents),
                tags: _.clone(req.tags)
            }));
        });
    }
    announceTlsErrorAsync(request) {
        return __awaiter(this, void 0, void 0, function* () {
            // We can get falsey but set hostname values - drop them
            if (!request.hostname)
                delete request.hostname;
            if (this.debug)
                console.warn(`TLS client error: ${JSON.stringify(request)}`);
            this.eventEmitter.emit('tlsClientError', request);
        });
    }
    handleRequest(rawRequest, rawResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.debug)
                console.log(`Handling request for ${rawRequest.url}`);
            const timingEvents = { startTime: Date.now(), startTimestamp: now() };
            const tags = [];
            const response = request_utils_1.trackResponse(rawResponse, timingEvents, tags);
            const id = uuid();
            const request = Object.assign(rawRequest, {
                id: id,
                timingEvents,
                tags
            });
            response.id = id;
            this.announceInitialRequestAsync(request);
            let result = null;
            const abort = () => {
                if (result === null) {
                    result = 'aborted';
                    request.timingEvents.abortedTimestamp = now();
                    this.announceAbortAsync(request);
                }
            };
            request.once('aborted', abort);
            let nextRulePromise = promise_1.filter(this.rules, (r) => r.matches(request))
                .then((matchingRules) => matchingRules.filter((r) => !this.isComplete(r, matchingRules))[0]);
            // Async: once we know what the next rule is, ping a request event
            nextRulePromise
                .then((rule) => rule ? rule.id : undefined)
                .catch(() => undefined)
                .then((ruleId) => {
                request.matchedRuleId = ruleId;
                this.announceCompletedRequestAsync(request);
            });
            try {
                let nextRule = yield nextRulePromise;
                if (nextRule) {
                    if (this.debug)
                        console.log(`Request matched rule: ${nextRule.explain()}`);
                    yield nextRule.handle(request, response, this.recordTraffic);
                }
                else {
                    yield this.sendUnmatchedRequestError(request, response);
                }
                result = result || 'responded';
            }
            catch (e) {
                if (e instanceof handlers_1.AbortError) {
                    abort();
                    if (this.debug) {
                        console.error("Failed to handle request due to abort:", e);
                    }
                }
                else {
                    if (this.debug) {
                        console.error("Failed to handle request:", e);
                    }
                    else {
                        console.error("Failed to handle request:", e.message);
                    }
                    // Make sure any errors here don't kill the process
                    response.on('error', (e) => { });
                    // Do whatever we can to tell the client we broke
                    try {
                        response.writeHead(e.statusCode || 500, e.statusMessage || 'Server error');
                    }
                    catch (e) { }
                    try {
                        response.end(e.toString());
                        result = result || 'responded';
                    }
                    catch (e) {
                        abort();
                    }
                }
            }
            if (result === 'responded') {
                this.announceResponseAsync(response);
            }
        });
    }
    sendUnmatchedRequestError(request, response) {
        return __awaiter(this, void 0, void 0, function* () {
            let requestExplanation = yield this.explainRequest(request);
            if (this.debug)
                console.warn(`Unmatched request received: ${requestExplanation}`);
            response.setHeader('Content-Type', 'text/plain');
            response.writeHead(503, "Request for unmocked endpoint");
            response.write("No rules were found matching this request.\n");
            response.write(`This request was: ${requestExplanation}\n\n`);
            if (this.rules.length > 0) {
                response.write("The configured rules are:\n");
                this.rules.forEach((rule) => response.write(rule.explain() + "\n"));
            }
            else {
                response.write("There are no rules configured.\n");
            }
            response.end(yield this.suggestRule(request));
        });
    }
    explainRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            let msg = `${request.method} request to ${request.url}`;
            let bodyText = yield request.body.asText();
            if (bodyText)
                msg += ` with body \`${bodyText}\``;
            if (!_.isEmpty(request.headers)) {
                msg += ` with headers:\n${JSON.stringify(request.headers, null, 2)}`;
            }
            return msg;
        });
    }
    suggestRule(request) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.suggestChanges)
                return '';
            let msg = "You can fix this by adding a rule to match this request, for example:\n";
            msg += `mockServer.${request.method.toLowerCase()}("${request.path}")`;
            const contentType = request.headers['content-type'];
            let isFormRequest = !!contentType && contentType.indexOf("application/x-www-form-urlencoded") > -1;
            let formBody = yield request.body.asFormData().catch(() => undefined);
            if (isFormRequest && !!formBody) {
                msg += `.withForm(${JSON.stringify(formBody)})`;
            }
            msg += '.thenReply(200, "your response");';
            return msg;
        });
    }
}
exports.default = MockttpServer;
//# sourceMappingURL=mockttp-server.js.map