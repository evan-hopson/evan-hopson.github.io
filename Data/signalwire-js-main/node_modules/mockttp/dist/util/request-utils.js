"use strict";
/**
 * @module Internal
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const stream = require("stream");
const querystring = require("querystring");
const zlib = require("zlib");
const brotliDecompress = require("brotli/decompress");
const now = require("performance-now");
const util_1 = require("../util/util");
// Is this URL fully qualified?
// Note that this supports only HTTP - no websockets or anything else.
exports.isAbsoluteUrl = (url) => url.toLowerCase().startsWith('http://') ||
    url.toLowerCase().startsWith('https://');
exports.isRelativeUrl = (url) => url.startsWith('/');
exports.isAbsoluteProtocollessUrl = (url) => !exports.isAbsoluteUrl(url) && !exports.isRelativeUrl(url);
exports.getUrlWithoutProtocol = (url) => {
    return url.split('://', 2).slice(-1).join('');
};
exports.getPathFromAbsoluteUrl = (url) => {
    const pathIndex = util_1.nthIndexOf(url, '/', 3);
    if (pathIndex !== -1) {
        return url.slice(pathIndex);
    }
    else {
        return '';
    }
};
exports.shouldKeepAlive = (req) => req.httpVersion !== '1.0' &&
    req.headers['connection'] !== 'close';
exports.setHeaders = (response, headers) => {
    Object.keys(headers).forEach((header) => {
        let value = headers[header];
        if (!value)
            return;
        response.setHeader(header, value);
    });
};
// Takes a buffer and a stream, returns a simple stream that outputs the buffer then the stream.
const bufferThenStream = (buffer, inputStream) => {
    const outputStream = new stream.PassThrough();
    // Forward the buffered data so far
    outputStream.write(Buffer.concat(buffer.currentChunks));
    // After the data, forward errors from the buffer
    if (buffer.failedWith) {
        // Announce async, to ensure listeners have time to get set up
        setTimeout(() => outputStream.emit('error', buffer.failedWith));
    }
    else {
        // Forward future data as it arrives
        inputStream.pipe(outputStream);
        // Forward any future errors from the input stream
        inputStream.once('error', (e) => outputStream.emit('error', e));
        // Silence 'unhandled rejection' warnings here, since we'll handle them on the stream instead
        buffer.catch(() => { });
    }
    return outputStream;
};
const bufferToStream = (buffer) => {
    const outputStream = new stream.PassThrough();
    outputStream.end(buffer);
    return outputStream;
};
exports.streamToBuffer = (input) => {
    const chunks = [];
    const bufferPromise = new Promise((resolve, reject) => {
        input.on('data', (d) => chunks.push(d));
        input.once('end', () => resolve(Buffer.concat(chunks)));
        input.once('aborted', () => {
            bufferPromise.failedWith = new Error('Aborted');
            reject(bufferPromise.failedWith);
        });
        input.once('error', (e) => {
            bufferPromise.failedWith = e;
            reject(e);
        });
    });
    bufferPromise.currentChunks = chunks;
    return bufferPromise;
};
const parseBodyStream = (bodyStream) => {
    let bufferPromise = null;
    let completedBuffer = null;
    let body = {
        // Returns a stream for the full body, not the live streaming body.
        // Each call creates a new stream, which starts with the already seen
        // and buffered data, and then continues with the live stream, if active.
        // Listeners to this stream *must* be attached synchronously after this call.
        asStream() {
            return completedBuffer
                ? bufferToStream(completedBuffer)
                : bufferThenStream(body.asBuffer(), bodyStream);
        },
        asBuffer() {
            if (!bufferPromise) {
                bufferPromise = exports.streamToBuffer(bodyStream);
                bufferPromise
                    .then((buffer) => completedBuffer = buffer)
                    .catch(() => { }); // If we get no body, completedBuffer stays null
            }
            return bufferPromise;
        },
        asText(encoding = 'utf8') {
            return body.asBuffer().then((b) => b.toString(encoding));
        },
        asJson() {
            return body.asText().then((t) => JSON.parse(t));
        },
        asFormData() {
            return body.asText().then((t) => querystring.parse(t));
        },
    };
    return body;
};
function runOrUndefined(func) {
    try {
        return func();
    }
    catch (_a) {
        return undefined;
    }
}
const waitForBody = (body, headers) => __awaiter(void 0, void 0, void 0, function* () {
    const bufferBody = yield body.asBuffer();
    return exports.buildBodyReader(bufferBody, headers);
});
exports.handleContentEncoding = (body, encoding) => {
    if (_.isArray(encoding) || (typeof encoding === 'string' && encoding.indexOf(', ') >= 0)) {
        const encodings = typeof encoding === 'string' ? encoding.split(', ').reverse() : encoding;
        return encodings.reduce((content, nextEncoding) => {
            return exports.handleContentEncoding(content, nextEncoding);
        }, body);
    }
    if (encoding === 'gzip' || encoding === 'x-gzip') {
        return zlib.gunzipSync(body);
    }
    else if (encoding === 'deflate' || encoding === 'x-deflate') {
        // Deflate is ambiguous, and may or may not have a zlib wrapper.
        // This checks the buffer header directly, based on
        // https://stackoverflow.com/a/37528114/68051
        const lowNibble = body[0] & 0xF;
        if (lowNibble === 8) {
            return zlib.inflateSync(body);
        }
        else {
            return zlib.inflateRawSync(body);
        }
    }
    else if (encoding === 'br') {
        return new Buffer(brotliDecompress(body));
    }
    else if (encoding === 'amz-1.0') {
        // Weird encoding used by some AWS requests, actually just unencoded JSON:
        // https://docs.aws.amazon.com/en_us/AmazonCloudWatch/latest/APIReference/making-api-requests.html
        return body;
    }
    else if (!encoding || encoding === 'identity') {
        return body;
    }
    else {
        throw new Error(`Unknown encoding: ${encoding}`);
    }
};
exports.buildBodyReader = (body, headers) => {
    const completedBody = {
        buffer: body,
        get decodedBuffer() {
            return runOrUndefined(() => exports.handleContentEncoding(this.buffer, headers['content-encoding']));
        },
        get text() {
            return runOrUndefined(() => this.decodedBuffer.toString('utf8'));
        },
        get json() {
            return runOrUndefined(() => JSON.parse(completedBody.text));
        },
        get formData() {
            return runOrUndefined(() => completedBody.text ? querystring.parse(completedBody.text) : undefined);
        }
    };
    return completedBody;
};
exports.parseBody = (req, _res, next) => {
    let transformedRequest = req;
    transformedRequest.body = parseBodyStream(req);
    next();
};
function buildInitiatedRequest(request) {
    return Object.assign(Object.assign({}, _.pick(request, 'id', 'matchedRuleId', 'protocol', 'httpVersion', 'method', 'url', 'path', 'hostname', 'headers', 'tags')), { timingEvents: request.timingEvents });
}
exports.buildInitiatedRequest = buildInitiatedRequest;
function buildAbortedRequest(request) {
    const requestData = buildInitiatedRequest(request);
    return Object.assign(requestData, {
        // Exists for backward compat: really Abort events should have no body at all
        body: exports.buildBodyReader(Buffer.alloc(0), {})
    });
}
exports.buildAbortedRequest = buildAbortedRequest;
function waitForCompletedRequest(request) {
    return __awaiter(this, void 0, void 0, function* () {
        const body = yield waitForBody(request.body, request.headers);
        request.timingEvents.bodyReceivedTimestamp = request.timingEvents.bodyReceivedTimestamp || now();
        const requestData = buildInitiatedRequest(request);
        return Object.assign(requestData, { body });
    });
}
exports.waitForCompletedRequest = waitForCompletedRequest;
function trackResponse(response, timingEvents, tags) {
    let trackedResponse = response;
    if (!trackedResponse.getHeaders) {
        // getHeaders was added in 7.7. - if it's not available, polyfill it
        trackedResponse.getHeaders = function () { return this._headers; };
    }
    trackedResponse.timingEvents = timingEvents;
    trackedResponse.tags = tags;
    // Headers are sent when .writeHead or .write() are first called
    const trackingStream = new stream.PassThrough();
    const originalWriteHeader = trackedResponse.writeHead;
    const originalWrite = trackedResponse.write;
    const originalEnd = trackedResponse.end;
    trackedResponse.writeHead = function (...args) {
        if (!timingEvents.headersSentTimestamp) {
            timingEvents.headersSentTimestamp = now();
        }
        return originalWriteHeader.apply(this, args);
    };
    const trackingWrite = function (...args) {
        trackingStream.write.apply(trackingStream, args);
        return originalWrite.apply(this, args);
    };
    trackedResponse.write = trackingWrite;
    trackedResponse.end = function (...args) {
        // We temporarily disable write tracking here, as .end
        // can call this.write, but that write should not be
        // tracked, or we'll get duplicate writes when trackingStream
        // calls it on itself too.
        trackedResponse.write = originalWrite;
        trackingStream.end.apply(trackingStream, args);
        let result = originalEnd.apply(this, args);
        trackedResponse.write = trackingWrite;
        return result;
    };
    trackedResponse.body = parseBodyStream(trackingStream);
    return trackedResponse;
}
exports.trackResponse = trackResponse;
function waitForCompletedResponse(response) {
    return __awaiter(this, void 0, void 0, function* () {
        const body = yield waitForBody(response.body, response.getHeaders());
        response.timingEvents.responseSentTimestamp = response.timingEvents.responseSentTimestamp || now();
        return _(response).pick([
            'id',
            'statusCode',
            'statusMessage',
            'timingEvents',
            'tags'
        ]).assign({
            headers: response.getHeaders(),
            body: body
        }).valueOf();
    });
}
exports.waitForCompletedResponse = waitForCompletedResponse;
//# sourceMappingURL=request-utils.js.map