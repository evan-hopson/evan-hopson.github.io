"use strict";
/**
 * @module TLS
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const uuid = require("uuid/v4");
const forge = require("node-forge");
const { pki, md, util: { encode64 } } = forge;
const fs = require("./fs");
/**
 * Generate a CA certificate for mocking HTTPS.
 *
 * Returns a promise, for an object with key and cert properties,
 * containing the generated private key and certificate in PEM format.
 *
 * These can be saved to disk, and their paths passed
 * as HTTPS options to a Mockttp server.
 */
function generateCACertificate(options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        options = _.defaults({}, options, {
            commonName: 'Mockttp Testing CA - DO NOT TRUST - TESTING ONLY',
            bits: 2048
        });
        const keyPair = yield new Promise((resolve, reject) => {
            pki.rsa.generateKeyPair({ bits: options.bits }, (error, keyPair) => {
                if (error)
                    reject(error);
                else
                    resolve(keyPair);
            });
        });
        const cert = pki.createCertificate();
        cert.publicKey = keyPair.publicKey;
        cert.serialNumber = uuid().replace(/-/g, '');
        cert.validity.notBefore = new Date();
        // Make it valid for the last 24h - helps in cases where clocks slightly disagree
        cert.validity.notBefore.setDate(cert.validity.notBefore.getDate() - 1);
        cert.validity.notAfter = new Date();
        // Valid for the next year by default.
        cert.validity.notAfter.setFullYear(cert.validity.notAfter.getFullYear() + 1);
        cert.setSubject([{ name: 'commonName', value: options.commonName }]);
        cert.setExtensions([{
                name: 'basicConstraints',
                cA: true
            }]);
        // Self-issued too
        cert.setIssuer(cert.subject.attributes);
        // Self-sign the certificate - we're the root
        cert.sign(keyPair.privateKey, md.sha256.create());
        return {
            key: pki.privateKeyToPem(keyPair.privateKey),
            cert: pki.certificateToPem(cert)
        };
    });
}
exports.generateCACertificate = generateCACertificate;
function generateSPKIFingerprint(certPem) {
    let cert = pki.certificateFromPem(certPem.toString('utf8'));
    return encode64(pki.getPublicKeyFingerprint(cert.publicKey, {
        type: 'SubjectPublicKeyInfo',
        md: md.sha256.create(),
        encoding: 'binary'
    }));
}
exports.generateSPKIFingerprint = generateSPKIFingerprint;
function getCA(options) {
    return __awaiter(this, void 0, void 0, function* () {
        let httpsOptions;
        if (options.key && options.cert) {
            httpsOptions = options;
        }
        else if (options.keyPath && options.certPath) {
            let pathOptions = options;
            httpsOptions = yield Promise.all([
                fs.readFile(pathOptions.keyPath, 'utf8'),
                fs.readFile(pathOptions.certPath, 'utf8')
            ]).then(([keyContents, certContents]) => ({
                key: keyContents,
                cert: certContents,
                keyLength: pathOptions.keyLength
            }));
        }
        else {
            throw new Error('Unrecognized https options: you need to provide either a keyPath & certPath, or a key & cert.');
        }
        return new CA(httpsOptions.key, httpsOptions.cert, httpsOptions.keyLength || 1024);
    });
}
exports.getCA = getCA;
// We share a single keypair across all certificates in this process, and
// instantiate it once when the first CA is created, because it can be
// expensive (depending on the key length).
// This would be a terrible idea for a real server, but for a mock server
// it's ok - if anybody can steal this, they can steal the CA cert anyway.
let KEY_PAIR;
class CA {
    constructor(caKey, caCert, keyLength) {
        this.caKey = pki.privateKeyFromPem(caKey.toString('utf8'));
        this.caCert = pki.certificateFromPem(caCert.toString('utf8'));
        this.certCache = {};
        if (!KEY_PAIR || KEY_PAIR.length < keyLength) {
            // If we have no key, or not a long enough one, generate one.
            KEY_PAIR = Object.assign(pki.rsa.generateKeyPair(keyLength), { length: keyLength });
        }
    }
    generateCertificate(domain) {
        // TODO: Expire domains from the cache? Based on their actual expiry?
        if (this.certCache[domain])
            return this.certCache[domain];
        let cert = pki.createCertificate();
        cert.publicKey = KEY_PAIR.publicKey;
        cert.serialNumber = uuid().replace(/-/g, '');
        cert.validity.notBefore = new Date();
        // Make it valid for the last 24h - helps in cases where clocks slightly disagree.
        cert.validity.notBefore.setDate(cert.validity.notBefore.getDate() - 1);
        cert.validity.notAfter = new Date();
        // Valid for the next year by default. TODO: Shorten (and expire the cache) automatically.
        cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 1);
        cert.setSubject([
            { name: 'commonName', value: domain },
            { name: 'organizationName', value: 'Mockttp Cert - DO NOT TRUST' }
        ]);
        cert.setIssuer(this.caCert.subject.attributes);
        cert.setExtensions([{
                name: 'keyUsage',
                keyCertSign: true,
                digitalSignature: true,
                nonRepudiation: true,
                keyEncipherment: true,
                dataEncipherment: true
            }, {
                name: 'subjectAltName',
                altNames: [{
                        type: 2,
                        value: domain
                    }]
            }]);
        cert.sign(this.caKey, md.sha256.create());
        const generatedCertificate = {
            key: pki.privateKeyToPem(KEY_PAIR.privateKey),
            cert: pki.certificateToPem(cert),
            ca: pki.certificateToPem(this.caCert)
        };
        this.certCache[domain] = generatedCertificate;
        return generatedCertificate;
    }
}
exports.CA = CA;
//# sourceMappingURL=tls.js.map