"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const stream_1 = require("stream");
const uuid = require("uuid/v4");
const base64_arraybuffer_1 = require("base64-arraybuffer");
const request_utils_1 = require("./request-utils");
function serialize(obj, stream) {
    const channel = new ClientServerChannel(stream);
    const data = obj.serialize(channel);
    data.topicId = channel.topicId;
    return data;
}
exports.serialize = serialize;
function deserialize(data, stream, lookup) {
    const type = data.type;
    const channel = new ClientServerChannel(stream, data.topicId);
    const deserialized = lookup[type].deserialize(data, channel);
    // Wrap .dispose and ensure the channel is always disposed too.
    const builtinDispose = deserialized.dispose;
    deserialized.dispose = () => {
        builtinDispose();
        channel.dispose();
    };
    return deserialized;
}
exports.deserialize = deserialize;
class Serializable {
    serialize(_channel) {
        // By default, we assume data is transferrable as-is
        return this;
    }
    static deserialize(data, _channel) {
        // By default, we assume we just need to assign the right prototype
        return _.create(this.prototype, data);
    }
    // This rule is being unregistered. Any handlers who need to cleanup when they know
    // they're no longer in use should implement this and dispose accordingly.
    // Only deserialized rules are disposed - if the originating rule needs
    // disposing too, ping the channel and let it know.
    dispose() { }
}
exports.Serializable = Serializable;
const DISPOSE_MESSAGE = { disposeChannel: true };
// Wraps another stream, ensuring that messages go only to the paired channel on the
// other client/server. In practice, each handler gets one end of these streams in
// their serialize/deserialize methods, and can use them to sync live data reliably.
class ClientServerChannel extends stream_1.Duplex {
    constructor(rawStream, topicId) {
        super({ objectMode: true });
        this.rawStream = rawStream;
        this._readFromRawStream = (rawData) => {
            const stringData = rawData.toString();
            stringData.split('\n').filter(d => !!d).forEach((rawDataLine) => {
                let data;
                try {
                    data = JSON.parse(rawDataLine);
                }
                catch (e) {
                    console.log(e);
                    console.log('Received unparseable message, dropping.', rawDataLine.toString());
                    return;
                }
                if (data.topicId === this.topicId) {
                    if (_.isEqual(data, DISPOSE_MESSAGE))
                        this.dispose();
                    else
                        this.push(data);
                }
            });
        };
        this.reading = false;
        this.topicId = topicId || uuid();
    }
    _write(message, encoding, callback) {
        message.topicId = this.topicId;
        const chunk = JSON.stringify(message) + '\n';
        if (!this.rawStream.write(chunk, encoding)) {
            this.rawStream.once('drain', callback);
        }
        else {
            callback();
        }
    }
    _read() {
        if (!this.reading) {
            this.rawStream.on('data', this._readFromRawStream);
            this.reading = true;
        }
    }
    request(actionOrData, dataOrNothing) {
        let action;
        let data;
        if (_.isString(actionOrData)) {
            action = actionOrData;
            data = dataOrNothing;
        }
        else {
            data = actionOrData;
        }
        const requestId = uuid();
        return new Promise((resolve, reject) => {
            const responseListener = (response) => {
                if (response.requestId === requestId) {
                    if (response.error) {
                        // Derialize error from plain object
                        reject(Object.assign(new Error(), { stack: undefined }, response.error));
                    }
                    else {
                        resolve(response.data);
                    }
                    this.removeListener('data', responseListener);
                }
            };
            const request = { data, requestId };
            if (action)
                request.action = action;
            this.write(request, (e) => {
                if (e)
                    reject(e);
                else
                    this.on('data', responseListener);
            });
        });
    }
    onRequest(cbOrAction, cbOrNothing) {
        let actionName;
        let cb;
        if (_.isString(cbOrAction)) {
            actionName = cbOrAction;
            cb = cbOrNothing;
        }
        else {
            cb = cbOrAction;
        }
        this.on('data', (request) => __awaiter(this, void 0, void 0, function* () {
            const { requestId, action } = request;
            // Filter by actionName, if set
            if (actionName !== undefined && action !== actionName)
                return;
            try {
                const response = {
                    requestId,
                    data: yield cb(request.data)
                };
                this.write(response);
            }
            catch (error) {
                // Make the error serializable:
                error = _.pick(error, Object.getOwnPropertyNames(error));
                this.write({ requestId, error });
            }
        }));
    }
    // Shuts down the channel. Only needs to be called on one side, the other side
    // will be shut down automatically when it receives DISPOSE_MESSAGE.
    dispose() {
        this.end(DISPOSE_MESSAGE);
        // Kill any remaining channel usage:
        this.removeAllListeners();
        // Stop receiving upstream messages from the global stream:
        this.rawStream.removeListener('data', this._readFromRawStream);
    }
}
exports.ClientServerChannel = ClientServerChannel;
function serializeBuffer(buffer) {
    return buffer.toString('base64');
}
exports.serializeBuffer = serializeBuffer;
function deserializeBuffer(buffer) {
    return Buffer.from(buffer, 'base64');
}
exports.deserializeBuffer = deserializeBuffer;
function withSerializedBodyReader(input) {
    return Object.assign({}, input, { body: input.body.buffer.toString('base64') });
}
exports.withSerializedBodyReader = withSerializedBodyReader;
function withDeserializedBodyReader(input) {
    return Object.assign({}, input, {
        body: request_utils_1.buildBodyReader(deserializeBuffer(input.body), input.headers)
    });
}
exports.withDeserializedBodyReader = withDeserializedBodyReader;
function withSerializedBodyBuffer(input) {
    let serializedBody;
    if (!input.body) {
        serializedBody = undefined;
    }
    else if (_.isString(input.body)) {
        serializedBody = serializeBuffer(Buffer.from(input.body));
    }
    else if (_.isBuffer(input.body)) {
        serializedBody = serializeBuffer(input.body);
    }
    else if (_.isArrayBuffer(input.body) || _.isTypedArray(input.body)) {
        serializedBody = base64_arraybuffer_1.encode(input.body);
    }
    else if (input.body.hasOwnProperty('decodedBuffer')) {
        serializedBody = serializeBuffer(input.body.buffer);
    }
    return Object.assign({}, input, { body: serializedBody });
}
exports.withSerializedBodyBuffer = withSerializedBodyBuffer;
function withDeserializedBodyBuffer(input) {
    if (input.body === undefined)
        return input;
    return Object.assign({}, input, {
        body: Buffer.from(input.body, 'base64')
    });
}
exports.withDeserializedBodyBuffer = withDeserializedBodyBuffer;
//# sourceMappingURL=serialization.js.map