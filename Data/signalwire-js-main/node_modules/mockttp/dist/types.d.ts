/**
 * @module Internal
 */
/// <reference types="node" />
import stream = require('stream');
import express = require("express");
import { EventEmitter } from 'events';
export declare const DEFAULT_STANDALONE_PORT = 45456;
export declare enum Method {
    GET = 0,
    POST = 1,
    PUT = 2,
    DELETE = 3,
    PATCH = 4,
    HEAD = 5,
    OPTIONS = 6
}
export interface Headers {
    host?: string;
    'content-length'?: string;
    'content-type'?: string;
    'user-agent'?: string;
    [key: string]: undefined | string | string[];
}
export interface RequestHeaders extends Headers {
    host: string;
    cookie?: string;
}
export interface Request {
    id: string;
    matchedRuleId?: string;
    protocol: string;
    httpVersion?: string;
    method: string;
    url: string;
    path: string;
    hostname?: string;
    headers: RequestHeaders;
    timingEvents: TimingEvents | {};
    tags: string[];
}
export interface TlsRequest {
    hostname?: string;
    remoteIpAddress: string;
    failureCause: 'closed' | 'reset' | 'cert-rejected' | 'no-shared-cipher' | 'unknown';
    tags: string[];
}
export interface OngoingRequest extends Request, EventEmitter {
    body: ParsedBody;
    timingEvents: TimingEvents;
}
export interface ParsedBody {
    asStream: () => stream.Readable;
    asBuffer: () => Promise<Buffer>;
    asText: () => Promise<string>;
    asJson: () => Promise<object>;
    asFormData: () => Promise<{
        [key: string]: string | string[];
    }>;
}
export interface CompletedBody {
    buffer: Buffer;
    decodedBuffer: Buffer | undefined;
    text: string | undefined;
    json: object | undefined;
    formData: {
        [key: string]: string | string[];
    } | undefined;
}
export interface InitiatedRequest extends Request {
    timingEvents: TimingEvents;
}
export interface CompletedRequest extends Request {
    body: CompletedBody;
}
export interface TimingEvents {
    startTime: number;
    startTimestamp: number;
    bodyReceivedTimestamp?: number;
    headersSentTimestamp?: number;
    responseSentTimestamp?: number;
    abortedTimestamp?: number;
}
export interface OngoingResponse extends express.Response {
    id: string;
    getHeaders(): Headers;
    body: ParsedBody;
    timingEvents: TimingEvents;
    tags: string[];
}
export interface CompletedResponse {
    id: string;
    statusCode: number;
    statusMessage: string;
    headers: Headers;
    body: CompletedBody;
    timingEvents: TimingEvents | {};
    tags: string[];
}
/**
 * A mocked endpoint provides methods to see the current state of
 * a mock rule.
 */
export interface MockedEndpoint {
    id: string;
    /**
     * Get the requests that this endpoint has seen so far.
     *
     * This method returns a promise, which resolves with the requests seen
     * up until now. The returned lists are immutable, so won't change if more
     * requests rrive in future. Call `getSeenRequests` again later to get
     * an updated list.
     */
    getSeenRequests(): Promise<CompletedRequest[]>;
}
export interface MockedEndpointData {
    id: string;
    seenRequests: CompletedRequest[];
}
export interface Explainable {
    explain(): string;
}
export interface ProxyConfig {
    HTTP_PROXY: string;
    HTTPS_PROXY: string;
}
