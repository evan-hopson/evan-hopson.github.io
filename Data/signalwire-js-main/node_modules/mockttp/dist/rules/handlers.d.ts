/**
 * @module MockRule
 */
/// <reference types="node" />
import express = require("express");
import { Readable } from 'stream';
import { TypedError } from 'typed-error';
import { Serializable, ClientServerChannel } from "../util/serialization";
import { MaybePromise } from '../util/type-utils';
import { Headers, RequestHeaders, OngoingRequest, CompletedRequest, OngoingResponse, CompletedBody, Explainable } from "../types";
export declare class AbortError extends TypedError {
}
export declare type SerializedBuffer = {
    type: 'Buffer';
    data: number[];
};
export interface CallbackRequestResult {
    method?: string;
    url?: string;
    headers?: RequestHeaders;
    json?: any;
    body?: string | Buffer;
    response?: CallbackResponseResult;
}
export interface CallbackResponseResult {
    statusCode?: number;
    status?: number;
    statusMessage?: string;
    headers?: Headers;
    json?: any;
    body?: string | Buffer;
}
export interface RequestHandler extends Explainable, Serializable {
    type: keyof typeof HandlerLookup;
    handle(request: OngoingRequest, response: OngoingResponse): Promise<void>;
}
export declare class SimpleHandler extends Serializable implements RequestHandler {
    status: number;
    statusMessage?: string | undefined;
    data?: string | Buffer | SerializedBuffer | undefined;
    headers?: Headers | undefined;
    readonly type = "simple";
    constructor(status: number, statusMessage?: string | undefined, data?: string | Buffer | SerializedBuffer | undefined, headers?: Headers | undefined);
    explain(): string;
    handle(_request: OngoingRequest, response: OngoingResponse): Promise<void>;
}
export interface SerializedCallbackHandlerData {
    type: string;
    name?: string;
}
export declare class CallbackHandler extends Serializable implements RequestHandler {
    callback: (request: CompletedRequest) => MaybePromise<CallbackResponseResult>;
    readonly type = "callback";
    constructor(callback: (request: CompletedRequest) => MaybePromise<CallbackResponseResult>);
    explain(): string;
    handle(request: OngoingRequest, response: express.Response): Promise<void>;
    serialize(channel: ClientServerChannel): SerializedCallbackHandlerData;
    static deserialize({ name }: SerializedCallbackHandlerData, channel: ClientServerChannel): CallbackHandler;
}
export interface SerializedStreamHandlerData {
    type: string;
    status: number;
    headers?: Headers;
}
export declare class StreamHandler extends Serializable implements RequestHandler {
    status: number;
    stream: Readable & {
        done?: true;
    };
    headers?: Headers | undefined;
    readonly type = "stream";
    constructor(status: number, stream: Readable & {
        done?: true;
    }, headers?: Headers | undefined);
    explain(): string;
    handle(_request: OngoingRequest, response: express.Response): Promise<void>;
    serialize(channel: ClientServerChannel): SerializedStreamHandlerData;
    static deserialize(handlerData: SerializedStreamHandlerData, channel: ClientServerChannel): StreamHandler;
}
export declare class FileHandler extends Serializable implements RequestHandler {
    status: number;
    statusMessage: string | undefined;
    filePath: string;
    headers?: Headers | undefined;
    readonly type = "file";
    constructor(status: number, statusMessage: string | undefined, filePath: string, headers?: Headers | undefined);
    explain(): string;
    handle(_request: OngoingRequest, response: OngoingResponse): Promise<void>;
}
export interface PassThroughResponse {
    id: string;
    statusCode: number;
    statusMessage?: string;
    headers: Headers;
    body: CompletedBody;
}
interface ForwardingOptions {
    targetHost: string;
    updateHostHeader?: true | false | string;
}
export interface PassThroughHandlerOptions {
    forwarding?: ForwardingOptions;
    ignoreHostCertificateErrors?: string[];
    clientCertificateHostMap?: {
        [host: string]: {
            pfx: Buffer;
            passphrase?: string;
        };
    };
    beforeRequest?: (req: CompletedRequest) => MaybePromise<CallbackRequestResult>;
    beforeResponse?: (res: PassThroughResponse) => MaybePromise<CallbackResponseResult>;
}
interface SerializedPassThroughData {
    type: 'passthrough';
    forwardToLocation?: string;
    forwarding?: ForwardingOptions;
    ignoreHostCertificateErrors?: string[];
    clientCertificateHostMap?: {
        [host: string]: {
            pfx: string;
            passphrase?: string;
        };
    };
    hasBeforeRequestCallback?: boolean;
    hasBeforeResponseCallback?: boolean;
}
export declare class PassThroughHandler extends Serializable implements RequestHandler {
    readonly type = "passthrough";
    readonly forwarding?: ForwardingOptions;
    readonly ignoreHostCertificateErrors: string[];
    readonly clientCertificateHostMap: {
        [host: string]: {
            pfx: Buffer;
            passphrase?: string;
        };
    };
    readonly beforeRequest?: (req: CompletedRequest) => MaybePromise<CallbackRequestResult>;
    readonly beforeResponse?: (res: PassThroughResponse) => MaybePromise<CallbackResponseResult>;
    constructor(options?: PassThroughHandlerOptions);
    explain(): string;
    handle(clientReq: OngoingRequest, clientRes: OngoingResponse): Promise<void>;
    serialize(channel: ClientServerChannel): SerializedPassThroughData;
    static deserialize(data: SerializedPassThroughData, channel: ClientServerChannel): PassThroughHandler;
}
export declare class CloseConnectionHandler extends Serializable implements RequestHandler {
    readonly type = "close-connection";
    explain(): string;
    handle(request: OngoingRequest): Promise<void>;
}
export declare class TimeoutHandler extends Serializable implements RequestHandler {
    readonly type = "timeout";
    explain(): string;
    handle(): Promise<void>;
}
export declare const HandlerLookup: {
    'simple': typeof SimpleHandler;
    'callback': typeof CallbackHandler;
    'stream': typeof StreamHandler;
    'file': typeof FileHandler;
    'passthrough': typeof PassThroughHandler;
    'close-connection': typeof CloseConnectionHandler;
    'timeout': typeof TimeoutHandler;
};
export {};
