"use strict";
/**
 * @module MockRule
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const url = require("url");
const common_tags_1 = require("common-tags");
const types_1 = require("../types");
const request_utils_1 = require("../util/request-utils");
const serialization_1 = require("../util/serialization");
const normalize_url_1 = require("../util/normalize-url");
function unescapeRegexp(input) {
    return input.replace(/\\\//g, '/');
}
class WildcardMatcher extends serialization_1.Serializable {
    constructor() {
        super(...arguments);
        this.type = 'wildcard';
    }
    matches() {
        return true;
    }
    explain() {
        return 'for anything';
    }
}
exports.WildcardMatcher = WildcardMatcher;
class MethodMatcher extends serialization_1.Serializable {
    constructor(method) {
        super();
        this.method = method;
        this.type = 'method';
    }
    matches(request) {
        return request.method === types_1.Method[this.method];
    }
    explain() {
        return `making ${types_1.Method[this.method]}s`;
    }
}
exports.MethodMatcher = MethodMatcher;
class HostMatcher extends serialization_1.Serializable {
    constructor(host) {
        super();
        this.host = host;
        this.type = 'host';
        // Validate the hostname. Goal here isn't to catch every bad hostname, but allow
        // every good hostname, and provide friendly errors for obviously bad hostnames.
        if (host.includes('/')) {
            throw new Error("Invalid hostname: hostnames can't contain slashes");
        }
        else if (host.includes('?')) {
            throw new Error("Invalid hostname: hostnames can't contain query strings");
        }
        else if (!host.match(/^([a-zA-Z0-9\-]+\.)*[a-zA-Z0-9\-]+(:\d+)?$/)) {
            throw new Error("Hostname is invalid");
        }
    }
    matches(request) {
        return new url.URL(request.url).host === this.host;
    }
    explain() {
        return `for host ${this.host}`;
    }
}
exports.HostMatcher = HostMatcher;
class SimplePathMatcher extends serialization_1.Serializable {
    constructor(path) {
        super();
        this.path = path;
        this.type = 'simple-path';
        if (!this.path)
            throw new Error('Invalid URL: URL to match must not be empty');
        let { search, query } = url.parse(this.path, true);
        if (search) {
            throw new Error(common_tags_1.oneLine `
                Tried to match a path that contained a query (${search}).
                To match query parameters, use .withQuery(${JSON.stringify(query)}) instead,
                or .withExactQuery('${search}') to match this exact query string.
            `);
        }
        normalize_url_1.normalizeUrl(this.path); // Fail if URL can't be normalized
    }
    matches(request) {
        const expectedUrl = normalize_url_1.normalizeUrl(this.path);
        const reqUrl = normalize_url_1.normalizeUrl(request.url);
        // reqUrl is always absolute, expectedUrl can be absolute, relative or protocolless-absolute
        if (request_utils_1.isRelativeUrl(expectedUrl)) {
            // Match the path only, for any host
            return request_utils_1.getPathFromAbsoluteUrl(reqUrl) === expectedUrl;
        }
        else if (request_utils_1.isAbsoluteUrl(expectedUrl)) {
            // Full absolute URL: match everything
            return reqUrl === expectedUrl;
        }
        else {
            // Absolute URL with no protocol
            return request_utils_1.getUrlWithoutProtocol(reqUrl) === expectedUrl;
        }
    }
    explain() {
        return `for ${this.path}`;
    }
    serialize(channel) {
        return Object.assign(super.serialize(channel), {
            // For backward compat, will used by older (<0.17) servers
            normalizedUrl: normalize_url_1.legacyNormalizeUrl(this.path)
        });
    }
}
exports.SimplePathMatcher = SimplePathMatcher;
class RegexPathMatcher extends serialization_1.Serializable {
    constructor(regex) {
        super();
        this.type = 'regex-path';
        this.regexSource = regex.source;
    }
    matches(request) {
        if (this.regexSource !== undefined) {
            const absoluteUrl = normalize_url_1.normalizeUrl(request.url);
            const urlPath = request_utils_1.getPathFromAbsoluteUrl(absoluteUrl);
            // Test the matcher against both the path alone & the full URL
            const urlMatcher = new RegExp(this.regexSource);
            return urlMatcher.test(absoluteUrl) ||
                urlMatcher.test(urlPath);
        }
        else {
            const { regexString } = this;
            // Old client, use old normalization & logic. Without this, old clients that check
            // example.com$ will fail to match (they should check ...com/$)
            let urlMatcher = new RegExp(regexString);
            return urlMatcher.test(normalize_url_1.legacyNormalizeUrl(request.url));
        }
    }
    explain() {
        return `matching /${unescapeRegexp(this.regexSource)}/`;
    }
    serialize(channel) {
        return Object.assign(super.serialize(channel), {
            // Backward compat for old servers
            regexString: this.regexSource
        });
    }
}
exports.RegexPathMatcher = RegexPathMatcher;
class HeaderMatcher extends serialization_1.Serializable {
    constructor(headersInput) {
        super();
        this.type = 'header';
        this.headers = _.mapKeys(headersInput, (_value, key) => key.toLowerCase());
    }
    matches(request) {
        return _.isMatch(request.headers, this.headers);
    }
    explain() {
        return `with headers including ${JSON.stringify(this.headers)}`;
    }
}
exports.HeaderMatcher = HeaderMatcher;
class ExactQueryMatcher extends serialization_1.Serializable {
    constructor(query) {
        super();
        this.query = query;
        this.type = 'exact-query-string';
        if (query !== '' && query[0] !== '?') {
            throw new Error('Exact query matches must start with ?, or be empty');
        }
    }
    matches(request) {
        const { search } = url.parse(request.url);
        return this.query === search || (!search && !this.query);
    }
    explain() {
        return this.query
            ? `with a query exactly matching \`${this.query}\``
            : 'with no query string';
    }
}
exports.ExactQueryMatcher = ExactQueryMatcher;
class QueryMatcher extends serialization_1.Serializable {
    constructor(queryObjectInput) {
        super();
        this.type = 'query';
        this.queryObject = _.mapValues(queryObjectInput, (v) => Array.isArray(v) ? v.map(av => av.toString()) : v.toString());
    }
    matches(request) {
        let { query } = url.parse(request.url, true);
        return _.isMatch(query, this.queryObject);
    }
    explain() {
        return `with a query including ${JSON.stringify(this.queryObject)}`;
    }
}
exports.QueryMatcher = QueryMatcher;
class FormDataMatcher extends serialization_1.Serializable {
    constructor(formData) {
        super();
        this.formData = formData;
        this.type = 'form-data';
    }
    matches(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = request.headers['content-type'];
            return !!contentType &&
                contentType.indexOf("application/x-www-form-urlencoded") !== -1 &&
                _.isMatch(yield request.body.asFormData(), this.formData);
        });
    }
    explain() {
        return `with form data including ${JSON.stringify(this.formData)}`;
    }
}
exports.FormDataMatcher = FormDataMatcher;
class RawBodyMatcher extends serialization_1.Serializable {
    constructor(content) {
        super();
        this.content = content;
        this.type = 'raw-body';
    }
    matches(request) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield request.body.asText()) === this.content;
        });
    }
    explain() {
        return `with body '${this.content}'`;
    }
}
exports.RawBodyMatcher = RawBodyMatcher;
class RegexBodyMatcher extends serialization_1.Serializable {
    constructor(regex) {
        super();
        this.type = 'raw-body-regexp';
        this.regexString = regex.source;
    }
    matches(request) {
        return __awaiter(this, void 0, void 0, function* () {
            let bodyMatcher = new RegExp(this.regexString);
            return bodyMatcher.test(yield request.body.asText());
        });
    }
    explain() {
        return `with body matching /${unescapeRegexp(this.regexString)}/`;
    }
}
exports.RegexBodyMatcher = RegexBodyMatcher;
class JsonBodyMatcher extends serialization_1.Serializable {
    constructor(body) {
        super();
        this.body = body;
        this.type = 'json-body';
    }
    matches(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const receivedBody = yield (request.body.asJson().catch(() => undefined));
            if (receivedBody === undefined)
                return false;
            else
                return _.isEqual(receivedBody, this.body);
        });
    }
    explain() {
        return `with ${JSON.stringify(this.body)} as a JSON body`;
    }
}
exports.JsonBodyMatcher = JsonBodyMatcher;
class JsonBodyFlexibleMatcher extends serialization_1.Serializable {
    constructor(body) {
        super();
        this.body = body;
        this.type = 'json-body-matching';
    }
    matches(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const receivedBody = yield (request.body.asJson().catch(() => undefined));
            if (receivedBody === undefined)
                return false;
            else
                return _.isMatch(receivedBody, this.body);
        });
    }
    explain() {
        return `with JSON body including ${JSON.stringify(this.body)}`;
    }
}
exports.JsonBodyFlexibleMatcher = JsonBodyFlexibleMatcher;
class CookieMatcher extends serialization_1.Serializable {
    constructor(cookie) {
        super();
        this.cookie = cookie;
        this.type = 'cookie';
    }
    matches(request) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!request.headers || !request.headers.cookie) {
                return false;
            }
            const cookies = request.headers.cookie.split(';').map(cookie => {
                const [key, value] = cookie.split('=');
                return { [key.trim()]: (value || '').trim() };
            });
            return cookies.some(element => _.isEqual(element, this.cookie));
        });
    }
    explain() {
        return `with cookies including ${JSON.stringify(this.cookie)}`;
    }
}
exports.CookieMatcher = CookieMatcher;
exports.MatcherLookup = {
    'wildcard': WildcardMatcher,
    'method': MethodMatcher,
    'host': HostMatcher,
    'simple-path': SimplePathMatcher,
    'regex-path': RegexPathMatcher,
    'header': HeaderMatcher,
    'query': QueryMatcher,
    'exact-query-string': ExactQueryMatcher,
    'form-data': FormDataMatcher,
    'raw-body': RawBodyMatcher,
    'raw-body-regexp': RegexBodyMatcher,
    'json-body': JsonBodyMatcher,
    'json-body-matching': JsonBodyFlexibleMatcher,
    'cookie': CookieMatcher,
};
function matchesAll(req, matchers) {
    return __awaiter(this, void 0, void 0, function* () {
        return _.every(yield Promise.all(matchers.map((matcher) => matcher.matches(req))));
    });
}
exports.matchesAll = matchesAll;
function explainMatchers(matchers) {
    if (matchers.length === 1)
        return matchers[0].explain();
    if (matchers.length === 2) {
        // With just two explanations, you can just combine them
        return `${matchers[0].explain()} ${matchers[1].explain()}`;
    }
    // With 3+, we need to oxford comma separate explanations to make them readable
    return matchers.slice(0, -1)
        .map((m) => m.explain())
        .join(', ') + ', and ' + matchers.slice(-1)[0].explain();
}
exports.explainMatchers = explainMatchers;
//# sourceMappingURL=matchers.js.map