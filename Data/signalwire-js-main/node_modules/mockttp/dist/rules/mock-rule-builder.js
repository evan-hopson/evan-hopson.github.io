"use strict";
/**
 * @module MockRule
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const completion_checkers_1 = require("./completion-checkers");
const matchers_1 = require("./matchers");
const handlers_1 = require("./handlers");
/**
 * @class MockRuleBuilder

 * A builder for defining mock rules. Create one using a method like
 * `.get(path)` or `.post(path)` on a Mockttp instance, then call
 * whatever methods you'd like here to define more precise request
 * matching behaviour, control how the request is handled, and how
 * many times this rule should be applied.
 *
 * When you're done, call a `.thenX()` method to register the configured rule
 * with the server. These return a promise for a MockedEndpoint, which can be
 * used to verify the details of the requests matched by the rule.
 *
 * This returns a promise because rule registration can be asynchronous,
 * either when using a remote server or testing in the browser. Wait for the
 * promise returned by `.thenX()` methods to guarantee that the rule has taken
 * effect before sending requests to it.
 */
class MockRuleBuilder {
    constructor(methodOrAddRule, path, addRule) {
        this.matchers = [];
        /**
         * Deprecated alias for thenJson
         * @deprecated
         */
        this.thenJSON = this.thenJson;
        if (methodOrAddRule instanceof Function) {
            this.matchers.push(new matchers_1.WildcardMatcher());
            this.addRule = methodOrAddRule;
            return;
        }
        this.matchers.push(new matchers_1.MethodMatcher(methodOrAddRule));
        if (path instanceof RegExp) {
            this.matchers.push(new matchers_1.RegexPathMatcher(path));
        }
        else if (typeof path === 'string') {
            this.matchers.push(new matchers_1.SimplePathMatcher(path));
        }
        this.addRule = addRule;
    }
    /**
     * Match only requests sent to the given host
     */
    forHost(host) {
        this.matchers.push(new matchers_1.HostMatcher(host));
        return this;
    }
    /**
     * Match only requests that include the given headers.
     */
    withHeaders(headers) {
        this.matchers.push(new matchers_1.HeaderMatcher(headers));
        return this;
    }
    /**
     * Match only requests that include the given query parameters.
     */
    withQuery(query) {
        this.matchers.push(new matchers_1.QueryMatcher(query));
        return this;
    }
    /**
     * Match only requests that include the exact query string provided.
     * The query string must start with a ? or be entirely empty.
     */
    withExactQuery(query) {
        this.matchers.push(new matchers_1.ExactQueryMatcher(query));
        return this;
    }
    /**
     * Match only requests whose bodies include the given form data.
     */
    withForm(formData) {
        this.matchers.push(new matchers_1.FormDataMatcher(formData));
        return this;
    }
    /**
     * Match only requests whose bodies either exactly match the given string
     * (if a string is passed) or whose bodies match a regular expression
     * (if a regex is passed).
     */
    withBody(content) {
        this.matchers.push(lodash_1.isString(content)
            ? new matchers_1.RawBodyMatcher(content)
            : new matchers_1.RegexBodyMatcher(content));
        return this;
    }
    /**
     * Match only requests whose bodies exactly match the given
     * object, when parsed as JSON.
     *
     * Note that this only tests that the body can be parsed
     * as JSON - it doesn't require a content-type header.
     */
    withJsonBody(json) {
        this.matchers.push(new matchers_1.JsonBodyMatcher(json));
        return this;
    }
    /**
     * Match only requests whose bodies match (contain equivalent
     * values, ignoring extra values) the given object, when
     * parsed as JSON. Matching behaviour is the same as Lodash's
     * _.isMatch method.
     *
     * Note that this only tests that the body can be parsed
     * as JSON - it doesn't require a content-type header.
     */
    withJsonBodyIncluding(json) {
        this.matchers.push(new matchers_1.JsonBodyFlexibleMatcher(json));
        return this;
    }
    /**
     * Match only requests that include the given cookies
     */
    withCookie(cookie) {
        this.matchers.push(new matchers_1.CookieMatcher(cookie));
        return this;
    }
    /**
     * Run this rule forever, for all matching requests
     */
    always() {
        this.completionChecker = new completion_checkers_1.Always();
        return this;
    }
    /**
     * Run this rule only once, for the first matching request
     */
    once() {
        this.completionChecker = new completion_checkers_1.Once();
        return this;
    }
    /**
     * Run this rule twice, for the first two matching requests
     */
    twice() {
        this.completionChecker = new completion_checkers_1.Twice();
        return this;
    }
    /**
     * Run this rule three times, for the first three matching requests
     */
    thrice() {
        this.completionChecker = new completion_checkers_1.Thrice();
        return this;
    }
    /**
     * Run this rule the given number of times, for the first matching requests
     */
    times(n) {
        this.completionChecker = new completion_checkers_1.NTimes(n);
        return this;
    }
    thenReply(status, dataOrMessage, dataOrHeaders, headers) {
        let data;
        let statusMessage;
        if (lodash_1.isBuffer(dataOrHeaders) || lodash_1.isString(dataOrHeaders)) {
            data = dataOrHeaders;
            statusMessage = dataOrMessage;
        }
        else {
            data = dataOrMessage;
            headers = dataOrHeaders;
        }
        const rule = {
            matchers: this.matchers,
            completionChecker: this.completionChecker,
            handler: new handlers_1.SimpleHandler(status, statusMessage, data, headers)
        };
        return this.addRule(rule);
    }
    /**
     * Reply to matched requests with the given status & JSON and (optionally)
     * extra headers.
     *
     * This method is shorthand for:
     * server.get(...).thenReply(status, JSON.stringify(data), { 'Content-Type': 'application/json' })
     *
     * Calling this method registers the rule with the server, so it
     * starts to handle requests.
     *
     * This method returns a promise that resolves with a mocked endpoint.
     * Wait for the promise to confirm that the rule has taken effect
     * before sending requests to be matched. The mocked endpoint
     * can be used to assert on the requests matched by this rule.
     */
    thenJson(status, data, headers = {}) {
        const defaultHeaders = { 'Content-Type': 'application/json' };
        lodash_1.merge(defaultHeaders, headers);
        const rule = {
            matchers: this.matchers,
            completionChecker: this.completionChecker,
            handler: new handlers_1.SimpleHandler(status, undefined, JSON.stringify(data), defaultHeaders)
        };
        return this.addRule(rule);
    }
    /**
     * Call the given callback for any matched requests that are received,
     * and build a response from the result.
     *
     * The callback should return a response object or a promise for one.
     * The response object may include various fields to define the response.
     * All fields are optional, and default to being empty/blank, except for
     * the status, which defaults to 200.
     *
     * Valid fields are:
     * - `status` (number)
     * - `body` (string or buffer)
     * - `headers` (object with string keys & values)
     * - `json` (object, which will be sent as a JSON response)
     *
     * If the callback throws an exception, the server will return a 500
     * with the exception message.
     *
     * Calling this method registers the rule with the server, so it
     * starts to handle requests.
     *
     * This method returns a promise that resolves with a mocked endpoint.
     * Wait for the promise to confirm that the rule has taken effect
     * before sending requests to be matched. The mocked endpoint
     * can be used to assert on the requests matched by this rule.
     */
    thenCallback(callback) {
        const rule = {
            matchers: this.matchers,
            completionChecker: this.completionChecker,
            handler: new handlers_1.CallbackHandler(callback)
        };
        return this.addRule(rule);
    }
    /**
     * Respond immediately with the given status (and optionally, headers),
     * and then stream the given stream directly as the response body.
     *
     * Note that streams can typically only be read once, and as such
     * this rule will only successfully trigger once. Subsequent requests
     * will receive a 500 and an explanatory error message. To mock
     * repeated requests with streams, create multiple streams and mock
     * them independently.
     *
     * Calling this method registers the rule with the server, so it
     * starts to handle requests.
     *
     * This method returns a promise that resolves with a mocked endpoint.
     * Wait for the promise to confirm that the rule has taken effect
     * before sending requests to be matched. The mocked endpoint
     * can be used to assert on the requests matched by this rule.
     */
    thenStream(status, stream, headers) {
        const rule = {
            matchers: this.matchers,
            completionChecker: this.completionChecker,
            handler: new handlers_1.StreamHandler(status, stream, headers)
        };
        return this.addRule(rule);
    }
    thenFromFile(status, pathOrMessage, pathOrHeaders, headers) {
        let path;
        let statusMessage;
        if (lodash_1.isString(pathOrHeaders)) {
            path = pathOrHeaders;
            statusMessage = pathOrMessage;
        }
        else {
            path = pathOrMessage;
            headers = pathOrHeaders;
        }
        const rule = {
            matchers: this.matchers,
            completionChecker: this.completionChecker,
            handler: new handlers_1.FileHandler(status, statusMessage, path, headers)
        };
        return this.addRule(rule);
    }
    /**
     * Pass matched requests through to their real destination. This works
     * for proxied requests only, direct requests will be rejected with
     * an error.
     *
     * This method takes options to configure how the request is passed
     * through. The available options are:
     *
     * * ignoreHostCertificateErrors, a list of hostnames for which server
     *   certificate errors should be ignored (none, by default).
     * * clientCertificateHostMap, a mapping of hosts to client certificates to use,
     *   in the form of { key, cert } objects (none, by default)
     * * beforeRequest, a callback that will be passed the full request
     *   before it is passed through, and which returns an object that defines
     *   how the the request content should be changed before it's passed
     *   to the upstream server (details below).
     * * beforeResponse, a callback that will be passed the full response
     *   before it is completed, and which returns an object that defines
     *   how the the response content should be changed before it's returned
     *   to the client (details below).
     *
     * The beforeRequest & beforeResponse callbacks should return objects
     * defining how the request/response should be changed. All fields on
     * the object are optional. The valid fields are:
     *
     * Valid fields are:
     * - Request only: `method` (a replacement HTTP verb, capitalized)
     * - Request only: `url` (a full URL to send the request to)
     * - Request only: `response` (a response callback result: if provided
     *   this will be used directly, the request will not be passed through
     *   at all, and any beforeResponse callback will never fire)
     * - Response only: `status` (number, will replace the HTTP status code)
     * - Both: `headers` (object with string keys & values, replaces all
     *   headers if set)
     * - Both: `body` (string or buffer, replaces the body if set)
     * - Both: `json` (object, to be sent as a JSON-encoded body, taking
     *   precedence over `body` if both are set)
     *
     * Calling this method registers the rule with the server, so it
     * starts to handle requests.
     *
     * This method returns a promise that resolves with a mocked endpoint.
     * Wait for the promise to confirm that the rule has taken effect
     * before sending requests to be matched. The mocked endpoint
     * can be used to assert on the requests matched by this rule.
     */
    thenPassThrough(options) {
        const rule = {
            matchers: this.matchers,
            completionChecker: this.completionChecker,
            handler: new handlers_1.PassThroughHandler(options)
        };
        return this.addRule(rule);
    }
    /**
     * Forward matched requests on to the specified forwardToUrl. The url
     * specified must not include a path. Otherwise, an error is thrown.
     * The path portion of the original request url is used instead.
     *
     * The url may optionally contain a protocol. If it does, it will override
     * the protocol (and potentially the port, if unspecified) of the request.
     * If no protocol is specified, the protocol (and potentially the port)
     * of the original request URL will be used instead.
     *
     * This method also takes options to configure how the request is passed
     * through, see thenPassThrough for more details.
     *
     * Calling this method registers the rule with the server, so it
     * starts to handle requests.
     *
     * This method returns a promise that resolves with a mocked endpoint.
     * Wait for the promise to confirm that the rule has taken effect
     * before sending requests to be matched. The mocked endpoint
     * can be used to assert on the requests matched by this rule.
     */
    thenForwardTo(forwardToLocation, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const rule = {
                matchers: this.matchers,
                completionChecker: this.completionChecker,
                handler: new handlers_1.PassThroughHandler(Object.assign(Object.assign({}, options), { forwarding: Object.assign(Object.assign({}, options.forwarding), { targetHost: forwardToLocation }) }))
            };
            return this.addRule(rule);
        });
    }
    /**
     * Close connections that match this rule immediately, without
     * any status code or response.
     *
     * Calling this method registers the rule with the server, so it
     * starts to handle requests.
     *
     * This method returns a promise that resolves with a mocked endpoint.
     * Wait for the promise to confirm that the rule has taken effect
     * before sending requests to be matched. The mocked endpoint
     * can be used to assert on the requests matched by this rule.
     */
    thenCloseConnection() {
        const rule = {
            matchers: this.matchers,
            completionChecker: this.completionChecker,
            handler: new handlers_1.CloseConnectionHandler()
        };
        return this.addRule(rule);
    }
    /**
     * Hold open connections that match this rule, but never respond
     * with anything at all, typically causing a timeout on the client side.
     *
     * Calling this method registers the rule with the server, so it
     * starts to handle requests.
     *
     * This method returns a promise that resolves with a mocked endpoint.
     * Wait for the promise to confirm that the rule has taken effect
     * before sending requests to be matched. The mocked endpoint
     * can be used to assert on the requests matched by this rule.
     */
    thenTimeout() {
        const rule = {
            matchers: this.matchers,
            completionChecker: this.completionChecker,
            handler: new handlers_1.TimeoutHandler()
        };
        return this.addRule(rule);
    }
}
exports.default = MockRuleBuilder;
//# sourceMappingURL=mock-rule-builder.js.map