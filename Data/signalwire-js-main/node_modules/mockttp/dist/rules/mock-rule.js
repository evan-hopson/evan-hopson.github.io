"use strict";
/**
 * @module MockRule
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = require("uuid/v4");
const serialization_1 = require("../util/serialization");
const request_utils_1 = require("../util/request-utils");
const matchers = require("./matchers");
const handlers = require("./handlers");
const completionCheckers = require("./completion-checkers");
function validateMockRuleData(data) {
    if (!data.matchers || data.matchers.length === 0) {
        throw new Error('Cannot create a rule without at least one matcher');
    }
    if (!data.handler) {
        throw new Error('Cannot create a rule with no handler');
    }
}
function serializeRuleData(data, stream) {
    validateMockRuleData(data);
    return {
        id: data.id,
        matchers: data.matchers.map(m => serialization_1.serialize(m, stream)),
        handler: serialization_1.serialize(data.handler, stream),
        completionChecker: data.completionChecker && serialization_1.serialize(data.completionChecker, stream)
    };
}
exports.serializeRuleData = serializeRuleData;
;
function deserializeRuleData(data, stream) {
    return {
        id: data.id,
        matchers: data.matchers.map((m) => serialization_1.deserialize(m, stream, matchers.MatcherLookup)),
        handler: serialization_1.deserialize(data.handler, stream, handlers.HandlerLookup),
        completionChecker: data.completionChecker && serialization_1.deserialize(data.completionChecker, stream, completionCheckers.CompletionCheckerLookup)
    };
}
exports.deserializeRuleData = deserializeRuleData;
class MockRule {
    constructor(data) {
        this.requests = [];
        this.requestCount = 0;
        validateMockRuleData(data);
        this.id = data.id || uuid();
        this.matchers = data.matchers;
        this.handler = data.handler;
        this.completionChecker = data.completionChecker;
    }
    matches(request) {
        return matchers.matchesAll(request, this.matchers);
    }
    handle(req, res, record) {
        let completedPromise = (() => __awaiter(this, void 0, void 0, function* () {
            yield this.handler.handle(req, res);
            return request_utils_1.waitForCompletedRequest(req);
        }))();
        // Requests are added to rule.requests as soon as they start being handled,
        // as promises, which resolve when the response is complete.
        if (record) {
            this.requests.push(completedPromise);
        }
        // Even if traffic recording is disabled, the number of matched
        // requests is still tracked
        this.requestCount += 1;
        return completedPromise;
    }
    isComplete() {
        if (this.completionChecker) {
            return this.completionChecker.isComplete(this.requestCount);
        }
        else {
            return null;
        }
    }
    explain() {
        let explanation = `Match requests ${matchers.explainMatchers(this.matchers)}, ` +
            `and then ${this.handler.explain()}`;
        if (this.completionChecker) {
            explanation += `, ${this.completionChecker.explain(this.requestCount)}.`;
        }
        else {
            explanation += '.';
        }
        return explanation;
    }
    dispose() {
        this.handler.dispose();
        this.matchers.forEach(m => m.dispose());
        if (this.completionChecker)
            this.completionChecker.dispose();
    }
}
exports.MockRule = MockRule;
//# sourceMappingURL=mock-rule.js.map