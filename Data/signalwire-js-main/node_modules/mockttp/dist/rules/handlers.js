"use strict";
/**
 * @module MockRule
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const url = require("url");
const http = require("http");
const https = require("https");
const base64_arraybuffer_1 = require("base64-arraybuffer");
const stream_1 = require("stream");
const common_tags_1 = require("common-tags");
const typed_error_1 = require("typed-error");
const request_utils_1 = require("../util/request-utils");
const socket_util_1 = require("../util/socket-util");
const serialization_1 = require("../util/serialization");
const fs_1 = require("../util/fs");
// An error that indicates that the handler is aborting the request.
// This could be intentional, or an upstream server aborting the request.
class AbortError extends typed_error_1.TypedError {
}
exports.AbortError = AbortError;
function isSerializedBuffer(obj) {
    return obj && obj.type === 'Buffer' && !!obj.data;
}
class SimpleHandler extends serialization_1.Serializable {
    constructor(status, statusMessage, data, headers) {
        super();
        this.status = status;
        this.statusMessage = statusMessage;
        this.data = data;
        this.headers = headers;
        this.type = 'simple';
    }
    explain() {
        return `respond with status ${this.status}` +
            (this.statusMessage ? ` (${this.statusMessage})` : "") +
            (this.headers ? `, headers ${JSON.stringify(this.headers)}` : "") +
            (this.data ? ` and body "${this.data}"` : "");
    }
    handle(_request, response) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.headers) {
                request_utils_1.setHeaders(response, this.headers);
            }
            response.writeHead(this.status, this.statusMessage);
            if (isSerializedBuffer(this.data)) {
                this.data = new Buffer(this.data);
            }
            response.end(this.data || "");
        });
    }
}
exports.SimpleHandler = SimpleHandler;
function writeResponseFromCallback(result, response) {
    if (result.json !== undefined) {
        result.headers = _.assign(result.headers || {}, { 'Content-Type': 'application/json' });
        result.body = JSON.stringify(result.json);
        delete result.json;
    }
    if (result.headers) {
        request_utils_1.setHeaders(response, result.headers);
    }
    response.writeHead(result.statusCode || result.status || 200, result.statusMessage);
    response.end(result.body || "");
}
class CallbackHandler extends serialization_1.Serializable {
    constructor(callback) {
        super();
        this.callback = callback;
        this.type = 'callback';
    }
    explain() {
        return 'respond using provided callback' + (this.callback.name ? ` (${this.callback.name})` : '');
    }
    handle(request, response) {
        return __awaiter(this, void 0, void 0, function* () {
            let req = yield request_utils_1.waitForCompletedRequest(request);
            let outResponse;
            try {
                outResponse = yield this.callback(req);
            }
            catch (error) {
                response.writeHead(500, 'Callback handler threw an exception');
                response.end(error.toString());
                return;
            }
            writeResponseFromCallback(outResponse, response);
        });
    }
    serialize(channel) {
        channel.onRequest((streamMsg) => __awaiter(this, void 0, void 0, function* () {
            return serialization_1.withSerializedBodyBuffer(yield this.callback.apply(null, streamMsg.args));
        }));
        return { type: this.type, name: this.callback.name };
    }
    static deserialize({ name }, channel) {
        const rpcCallback = (request) => __awaiter(this, void 0, void 0, function* () {
            return serialization_1.withDeserializedBodyBuffer(yield channel.request({ args: [request] }));
        });
        // Pass across the name from the real callback, for explain()
        Object.defineProperty(rpcCallback, "name", { value: name });
        // Call the client's callback (via stream), and save a handler on our end for
        // the response that comes back.
        return new CallbackHandler(rpcCallback);
    }
}
exports.CallbackHandler = CallbackHandler;
;
class StreamHandler extends serialization_1.Serializable {
    constructor(status, stream, headers) {
        super();
        this.status = status;
        this.stream = stream;
        this.headers = headers;
        this.type = 'stream';
    }
    explain() {
        return `respond with status ${this.status}` +
            (this.headers ? `, headers ${JSON.stringify(this.headers)},` : "") +
            ' and a stream of response data';
    }
    handle(_request, response) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.stream.done) {
                if (this.headers) {
                    request_utils_1.setHeaders(response, this.headers);
                }
                response.writeHead(this.status);
                this.stream.pipe(response);
                this.stream.done = true;
            }
            else {
                throw new Error(common_tags_1.stripIndent `
                Stream request handler called more than once - this is not supported.

                Streams can typically only be read once, so all subsequent requests would be empty.
                To mock repeated stream requests, call 'thenStream' repeatedly with multiple streams.

                (Have a better way to handle this? Open an issue at ${require('../../package.json').bugs.url})
            `);
            }
        });
    }
    serialize(channel) {
        const serializationStream = new stream_1.Transform({
            objectMode: true,
            transform: function (chunk, _encoding, callback) {
                let serializedEventData = _.isString(chunk) ? { type: 'string', value: chunk } :
                    _.isBuffer(chunk) ? { type: 'buffer', value: chunk.toString('base64') } :
                        (_.isArrayBuffer(chunk) || _.isTypedArray(chunk)) ? { type: 'arraybuffer', value: base64_arraybuffer_1.encode(chunk) } :
                            _.isNil(chunk) && { type: 'nil' };
                if (!serializedEventData) {
                    callback(new Error(`Can't serialize streamed value: ${chunk.toString()}. Streaming must output strings, buffers or array buffers`));
                }
                callback(undefined, {
                    event: 'data',
                    content: serializedEventData
                });
            },
            flush: function (callback) {
                this.push({
                    event: 'end'
                });
                callback();
            }
        });
        // When we get a ping from the server-side, pipe the real stream to serialize it and send the data across
        channel.once('data', () => {
            this.stream.pipe(serializationStream).pipe(channel, { end: false });
        });
        return { type: this.type, status: this.status, headers: this.headers };
    }
    static deserialize(handlerData, channel) {
        const handlerStream = new stream_1.Transform({
            objectMode: true,
            transform: function (message, encoding, callback) {
                const { event, content } = message;
                let deserializedEventData = content && (content.type === 'string' ? content.value :
                    content.type === 'buffer' ? Buffer.from(content.value, 'base64') :
                        content.type === 'arraybuffer' ? Buffer.from(base64_arraybuffer_1.decode(content.value)) :
                            content.type === 'nil' && undefined);
                if (event === 'data' && deserializedEventData) {
                    this.push(deserializedEventData);
                }
                else if (event === 'end') {
                    this.end();
                }
                callback();
            }
        });
        // When we get piped (i.e. to a live request), ping upstream to start streaming, and then
        // pipe the resulting data into our live stream (which is streamed to the request, like normal)
        handlerStream.once('resume', () => {
            channel.pipe(handlerStream);
            channel.write({});
        });
        return new StreamHandler(handlerData.status, handlerStream, handlerData.headers);
    }
}
exports.StreamHandler = StreamHandler;
class FileHandler extends serialization_1.Serializable {
    constructor(status, statusMessage, filePath, headers) {
        super();
        this.status = status;
        this.statusMessage = statusMessage;
        this.filePath = filePath;
        this.headers = headers;
        this.type = 'file';
    }
    explain() {
        return `respond with status ${this.status}` +
            (this.statusMessage ? ` (${this.statusMessage})` : "") +
            (this.headers ? `, headers ${JSON.stringify(this.headers)}` : "") +
            (this.filePath ? ` and body from file ${this.filePath}` : "");
    }
    handle(_request, response) {
        return __awaiter(this, void 0, void 0, function* () {
            // Read the file first, to ensure we error cleanly if it's unavailable
            const fileContents = yield fs_1.readFile(this.filePath, null);
            if (this.headers)
                request_utils_1.setHeaders(response, this.headers);
            response.writeHead(this.status, this.statusMessage);
            response.end(fileContents);
        });
    }
}
exports.FileHandler = FileHandler;
// Used to drop `undefined` headers, which cause problems
function dropUndefinedValues(obj) {
    return _.omitBy(obj, (v) => v === undefined);
}
// Callback result bodies can take a few formats: tidy them up a little
function getCallbackResultBody(replacementBody) {
    if (replacementBody === undefined) {
        return replacementBody;
    }
    else if (replacementBody.hasOwnProperty('decodedBuffer')) {
        // It's our own bodyReader instance. That's not supposed to happen, but
        // it's ok, we just need to use the buffer data instead of the whole object
        return Buffer.from(replacementBody.buffer);
    }
    else if (replacementBody === '') {
        // For empty bodies, it's slightly more convenient if they're truthy
        return Buffer.alloc(0);
    }
    else {
        return replacementBody;
    }
}
// Helper to autocorrect the host header, but only if you didn't explicitly
// override it yourself for some reason (e.g. testing bad behaviour).
function getCorrectHost(reqUrl, originalHeaders, replacementHeaders) {
    const correctHost = url.parse(reqUrl).host;
    const replacementHost = !!replacementHeaders ? replacementHeaders['host'] : undefined;
    if (replacementHost !== undefined) {
        if (replacementHost !== correctHost && replacementHost === originalHeaders['host']) {
            // If you rewrite the host header wrongly, by explicitly setting it to the
            // existing value, we accept it, but print a warning. This would be easy to
            // do if you mutate the existing headers, for example, but not the host.
            console.warn(common_tags_1.oneLine `
                Passthrough callback overrode the URL and the Host header
                with mismatched values, which may be a mistake. The URL is
                ${reqUrl}, whilst the header was set to ${replacementHost}.
            `);
        }
        // Whatever happens, if you explicitly set a value, we use it.
        return replacementHost;
    }
    // If you didn't override the host at all, then we automatically ensure
    // the correct header is set automatically.
    return correctHost;
}
// Helper to handle content-length nicely for you when rewriting requests with callbacks
function getCorrectContentLength(body, originalHeaders, replacementHeaders, mismatchAllowed = false) {
    // If there was a content-length header, it might now be wrong, and it's annoying
    // to need to set your own content-length override when you just want to change
    // the body. To help out, if you override the body but don't explicitly override
    // the (now invalid) content-length, then we fix it for you.
    if (!_.has(originalHeaders, 'content-length')) {
        // Nothing to override - use the replacement value, or undefined
        return (replacementHeaders || {})['content-length'];
    }
    if (!replacementHeaders) {
        // There was a length set, and you've provided a body but not changed it.
        // You probably just want to send this body and have it work correctly,
        // so we should fix the content length for you automatically.
        return body.length.toString();
    }
    // There was a content length before, and you're replacing the headers entirely
    const lengthOverride = replacementHeaders['content-length'] === undefined
        ? undefined
        : replacementHeaders['content-length'].toString();
    // If you're setting the content-length to the same as the origin headers, even
    // though that's the wrong value, it *might* be that you're just extending the
    // existing headers, and you're doing this by accident (we can't tell for sure).
    // We use invalid content-length as instructed, but print a warning just in case.
    if (lengthOverride === originalHeaders['content-length'] &&
        lengthOverride !== body.length.toString() &&
        !mismatchAllowed // Set for HEAD responses
    ) {
        console.warn(common_tags_1.oneLine `
            Passthrough callback overrode the body and the content-length header
            with mismatched values, which may be a mistake. The body contains
            ${body.length} bytes, whilst the header was set to ${lengthOverride}.
        `);
    }
    return lengthOverride;
}
const KeepAliveAgents = {
    'http:': new http.Agent({
        keepAlive: true
    }),
    'https:': new https.Agent({
        keepAlive: true
    })
};
class PassThroughHandler extends serialization_1.Serializable {
    constructor(options = {}) {
        super();
        this.type = 'passthrough';
        this.ignoreHostCertificateErrors = [];
        // If a location is provided, and it's not a bare hostname, it must be parseable
        const { forwarding } = options;
        if (forwarding && forwarding.targetHost.includes('/')) {
            const { protocol, hostname, port, path } = url.parse(forwarding.targetHost);
            if (path && path.trim() !== "/") {
                const suggestion = url.format({ protocol, hostname, port }) ||
                    forwarding.targetHost.slice(0, forwarding.targetHost.indexOf('/'));
                throw new Error(common_tags_1.stripIndent `
                    URLs for forwarding cannot include a path, but "${forwarding.targetHost}" does. ${''}Did you mean ${suggestion}?
                `);
            }
        }
        this.forwarding = forwarding;
        this.ignoreHostCertificateErrors = options.ignoreHostCertificateErrors || [];
        this.clientCertificateHostMap = options.clientCertificateHostMap || {};
        this.beforeRequest = options.beforeRequest;
        this.beforeResponse = options.beforeResponse;
    }
    explain() {
        return this.forwarding
            ? `forward the request to ${this.forwarding.targetHost}`
            : 'pass the request through to the target host';
    }
    handle(clientReq, clientRes) {
        return __awaiter(this, void 0, void 0, function* () {
            // Capture raw request data:
            let { method, url: reqUrl, headers } = clientReq;
            let { protocol, hostname, port, path } = url.parse(reqUrl);
            if (this.forwarding) {
                const { targetHost, updateHostHeader } = this.forwarding;
                if (!targetHost.includes('/')) {
                    // We're forwarding to a bare hostname
                    [hostname, port] = targetHost.split(':');
                }
                else {
                    // We're forwarding to a fully specified URL; override the host etc, but never the path.
                    ({ protocol, hostname, port } = url.parse(targetHost));
                }
                if (updateHostHeader === undefined || updateHostHeader === true) {
                    // If updateHostHeader is true, or just not specified, match the new target
                    headers['host'] = hostname + (port ? `:${port}` : '');
                }
                else if (updateHostHeader) {
                    // If it's an explicit custom value, use that directly.
                    headers['host'] = updateHostHeader;
                } // Otherwise: falsey means don't touch it.
            }
            // Check if this request is a request loop:
            if (isRequestLoop(clientReq.socket)) {
                throw new Error(common_tags_1.oneLine `
                Passthrough loop detected. This probably means you're sending a request directly
                to a passthrough endpoint, which is forwarding it to the target URL, which is a
                passthrough endpoint, which is forwarding it to the target URL, which is a
                passthrough endpoint...` +
                    '\n\n' + common_tags_1.oneLine `
                You should either explicitly mock a response for this URL (${reqUrl}), or use
                the server as a proxy, instead of making requests to it directly.
            `);
            }
            // Make sure the URL is absolute, if we're transparent proxying, or redirecting/proxying
            // to URLs on this mock server (instead of externally).
            if (!hostname) {
                const hostHeader = headers.host;
                [hostname, port] = hostHeader.split(':');
                protocol = clientReq.protocol + ':';
            }
            // Override the request details, if a callback is specified:
            let reqBodyOverride;
            if (this.beforeRequest) {
                const modifiedReq = yield this.beforeRequest(yield request_utils_1.waitForCompletedRequest(Object.assign({}, clientReq, {
                    url: new url.URL(reqUrl, `${protocol}//${hostname}${port ? `:${port}` : ''}`).toString()
                })));
                if (modifiedReq.response) {
                    // The callback has provided a full response: don't passthrough at all, just use it.
                    writeResponseFromCallback(modifiedReq.response, clientRes);
                    return;
                }
                method = modifiedReq.method || method;
                reqUrl = modifiedReq.url || reqUrl;
                headers = modifiedReq.headers || headers;
                headers['host'] = getCorrectHost(reqUrl, clientReq.headers, modifiedReq.headers);
                if (modifiedReq.json) {
                    headers['content-type'] = 'application/json';
                    reqBodyOverride = JSON.stringify(modifiedReq.json);
                }
                else {
                    reqBodyOverride = getCallbackResultBody(modifiedReq.body);
                }
                if (reqBodyOverride !== undefined) {
                    headers['content-length'] = getCorrectContentLength(reqBodyOverride, clientReq.headers, modifiedReq.headers);
                }
                headers = dropUndefinedValues(headers);
                // Reparse the new URL, if necessary
                if (modifiedReq.url) {
                    ({ protocol, hostname, port, path } = url.parse(reqUrl));
                }
            }
            const hostWithPort = `${hostname}:${port}`;
            // Ignore cert errors if the host+port or whole hostname is whitelisted
            const checkServerCertificate = !_.includes(this.ignoreHostCertificateErrors, hostname) &&
                !_.includes(this.ignoreHostCertificateErrors, hostWithPort);
            // Use a client cert if it's listed for the  host+port or whole hostname
            const clientCert = this.clientCertificateHostMap[hostWithPort] ||
                this.clientCertificateHostMap[hostname] ||
                {};
            let makeRequest = protocol === 'https:' ? https.request : http.request;
            let family;
            if (hostname === 'localhost') {
                // Annoying special case: some localhost servers listen only on either ipv4 or ipv6.
                // Very specific situation, but a very common one for development use.
                // We need to work out which one family is, as Node sometimes makes bad choices.
                const portToTest = !!port
                    ? parseInt(port, 10)
                    : (protocol === 'https:' ? 443 : 80);
                if (yield socket_util_1.isLocalPortActive('::1', portToTest))
                    family = 6;
                else
                    family = 4;
            }
            // Mirror the keep-alive-ness of the incoming request in our outgoing request
            const agent = request_utils_1.shouldKeepAlive(clientReq)
                ? KeepAliveAgents[protocol || 'http:']
                : undefined;
            return new Promise((resolve, reject) => {
                let serverReq = makeRequest(Object.assign({ protocol,
                    method,
                    hostname,
                    port,
                    family,
                    path,
                    headers,
                    agent, rejectUnauthorized: checkServerCertificate }, clientCert), (serverRes) => __awaiter(this, void 0, void 0, function* () {
                    serverRes.once('error', reject);
                    let serverStatusCode = serverRes.statusCode;
                    let serverStatusMessage = serverRes.statusMessage;
                    let serverHeaders = serverRes.headers;
                    let resBodyOverride;
                    if (this.beforeResponse) {
                        let modifiedRes;
                        let body;
                        try {
                            body = yield request_utils_1.streamToBuffer(serverRes);
                            modifiedRes = yield this.beforeResponse({
                                id: clientReq.id,
                                statusCode: serverStatusCode,
                                statusMessage: serverRes.statusMessage,
                                headers: serverHeaders,
                                body: request_utils_1.buildBodyReader(body, serverHeaders)
                            });
                        }
                        catch (e) {
                            serverReq.abort();
                            return reject(e);
                        }
                        serverStatusCode = modifiedRes.statusCode ||
                            modifiedRes.status ||
                            serverStatusCode;
                        serverStatusMessage = modifiedRes.statusMessage ||
                            serverStatusMessage;
                        serverHeaders = modifiedRes.headers || serverHeaders;
                        if (modifiedRes.json) {
                            serverHeaders['content-type'] = 'application/json';
                            resBodyOverride = JSON.stringify(modifiedRes.json);
                        }
                        else {
                            resBodyOverride = getCallbackResultBody(modifiedRes.body);
                        }
                        if (resBodyOverride !== undefined) {
                            serverHeaders['content-length'] = getCorrectContentLength(resBodyOverride, serverRes.headers, modifiedRes.headers, method === 'HEAD' // HEAD responses are allowed mismatched content-length
                            );
                        }
                        else {
                            // If you don't specify a body override, we need to use the real
                            // body anyway, because as we've read it already streaming it to
                            // the response won't work
                            resBodyOverride = body;
                        }
                        serverHeaders = dropUndefinedValues(serverHeaders);
                    }
                    Object.keys(serverHeaders).forEach((header) => {
                        const headerValue = serverHeaders[header];
                        if (headerValue === undefined)
                            return;
                        try {
                            clientRes.setHeader(header, headerValue);
                        }
                        catch (e) {
                            // A surprising number of real sites have slightly invalid headers
                            // (e.g. extra spaces). If we hit any, we just drop that header
                            // and print a warning.
                            console.log(`Error setting header on passthrough response: ${e.message}`);
                        }
                    });
                    clientRes.statusMessage = serverStatusMessage || clientRes.statusMessage;
                    clientRes.status(serverStatusCode);
                    if (resBodyOverride) {
                        clientRes.end(resBodyOverride);
                        resolve();
                    }
                    else {
                        serverRes.pipe(clientRes);
                        serverRes.once('end', resolve);
                    }
                }));
                serverReq.once('socket', (socket) => {
                    // This event can fire multiple times for keep-alive sockets, which are used to
                    // make multiple requests. If/when that happens, we don't need more event listeners.
                    if (currentlyForwardingSockets.has(socket))
                        return;
                    // Add this port to our list of active ports, once it's connected (before then it has no port)
                    socket.once('connect', () => currentlyForwardingSockets.add(socket));
                    // Remove this port from our list of active ports when it's closed
                    // This is called for both clean closes & errors.
                    socket.once('close', () => currentlyForwardingSockets.delete(socket));
                });
                if (reqBodyOverride) {
                    serverReq.end(reqBodyOverride);
                }
                else {
                    // asStream includes all content, including the body before this call
                    const reqBodyStream = clientReq.body.asStream();
                    reqBodyStream.pipe(serverReq);
                    reqBodyStream.once('error', () => serverReq.abort());
                }
                clientReq.once('abort', () => serverReq.abort());
                clientRes.once('close', () => serverReq.abort());
                serverReq.once('error', (e) => {
                    if (serverReq.aborted)
                        return;
                    // Tag responses, so programmatic examination can react to this
                    // event, without having to parse response data or similar.
                    const tlsAlertMatch = /SSL alert number (\d+)/.exec(e.message);
                    if (tlsAlertMatch) {
                        clientRes.tags.push('passthrough-tls-error:ssl-alert-' + tlsAlertMatch[1]);
                    }
                    clientRes.tags.push('passthrough-error:' + e.code);
                    if (e.code === 'ECONNRESET') {
                        // The upstream socket closed: forcibly close the downstream too, to match
                        clientReq.socket.end();
                        reject(new AbortError('Upstream connection was reset'));
                    }
                    else {
                        e.statusCode = 502;
                        e.statusMessage = 'Error communicating with upstream server';
                        reject(e);
                    }
                });
            });
        });
    }
    serialize(channel) {
        if (this.beforeRequest) {
            channel.onRequest('beforeRequest', (req) => __awaiter(this, void 0, void 0, function* () {
                const result = serialization_1.withSerializedBodyBuffer(yield this.beforeRequest(serialization_1.withDeserializedBodyReader(req.args[0])));
                if (result.response) {
                    result.response = serialization_1.withSerializedBodyBuffer(result.response);
                }
                return result;
            }));
        }
        if (this.beforeResponse) {
            channel.onRequest('beforeResponse', (req) => __awaiter(this, void 0, void 0, function* () {
                return serialization_1.withSerializedBodyBuffer(yield this.beforeResponse(serialization_1.withDeserializedBodyReader(req.args[0])));
            }));
        }
        return Object.assign(Object.assign({ type: this.type }, this.forwarding ? {
            forwardToLocation: this.forwarding.targetHost,
            forwarding: this.forwarding
        } : {}), { ignoreHostCertificateErrors: this.ignoreHostCertificateErrors, clientCertificateHostMap: _.mapValues(this.clientCertificateHostMap, ({ pfx, passphrase }) => ({ pfx: serialization_1.serializeBuffer(pfx), passphrase })), hasBeforeRequestCallback: !!this.beforeRequest, hasBeforeResponseCallback: !!this.beforeResponse });
    }
    static deserialize(data, channel) {
        let beforeRequest;
        let beforeResponse;
        if (data.hasBeforeRequestCallback) {
            beforeRequest = (req) => __awaiter(this, void 0, void 0, function* () {
                const result = serialization_1.withDeserializedBodyBuffer(yield channel.request('beforeRequest', {
                    args: [serialization_1.withSerializedBodyReader(req)]
                }));
                if (result.response) {
                    result.response = serialization_1.withDeserializedBodyBuffer(result.response);
                }
                return result;
            });
        }
        if (data.hasBeforeResponseCallback) {
            beforeResponse = (res) => __awaiter(this, void 0, void 0, function* () {
                return serialization_1.withDeserializedBodyBuffer(yield channel.request('beforeResponse', {
                    args: [serialization_1.withSerializedBodyReader(res)]
                }));
            });
        }
        return new PassThroughHandler(Object.assign(Object.assign({ beforeRequest,
            beforeResponse }, data.forwardToLocation ? {
            forwarding: { targetHost: data.forwardToLocation }
        } : {}), { forwarding: data.forwarding, ignoreHostCertificateErrors: data.ignoreHostCertificateErrors, clientCertificateHostMap: _.mapValues(data.clientCertificateHostMap, ({ pfx, passphrase }) => ({ pfx: serialization_1.deserializeBuffer(pfx), passphrase })) }));
    }
}
exports.PassThroughHandler = PassThroughHandler;
class CloseConnectionHandler extends serialization_1.Serializable {
    constructor() {
        super(...arguments);
        this.type = 'close-connection';
    }
    explain() {
        return 'close the connection';
    }
    handle(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const socket = request.socket;
            socket.end();
            throw new AbortError('Connection closed (intentionally)');
        });
    }
}
exports.CloseConnectionHandler = CloseConnectionHandler;
class TimeoutHandler extends serialization_1.Serializable {
    constructor() {
        super(...arguments);
        this.type = 'timeout';
    }
    explain() {
        return 'time out (never respond)';
    }
    handle() {
        return __awaiter(this, void 0, void 0, function* () {
            // Do nothing, leaving the socket open but never sending a response.
            return new Promise(() => { });
        });
    }
}
exports.TimeoutHandler = TimeoutHandler;
exports.HandlerLookup = {
    'simple': SimpleHandler,
    'callback': CallbackHandler,
    'stream': StreamHandler,
    'file': FileHandler,
    'passthrough': PassThroughHandler,
    'close-connection': CloseConnectionHandler,
    'timeout': TimeoutHandler
};
// Passthrough handlers need to spot loops - tracking ongoing sockets lets us get pretty
// close to doing that (for 1 step loops, at least):
// We keep a list of all currently active outgoing sockets.
const currentlyForwardingSockets = new Set();
// We need to normalize ips for comparison, because the same ip may be reported as ::ffff:127.0.0.1
// and 127.0.0.1 on the two sides of the connection, for the same ip.
const normalizeIp = (ip) => (ip && ip.startsWith('::ffff:'))
    ? ip.slice('::ffff:'.length)
    : ip;
// For incoming requests, compare the address & port: if they match, we've almost certainly got a loop.
// I don't think it's generally possible to see the same ip on different interfaces from one process (you need
// ip-netns network namespaces), but if it is, then there's a tiny chance of false positives here. If we have ip X,
// and on another interface somebody else has ip X, and the send a request with the same incoming port as an
// outgoing request we have on the other interface, we'll assume it's a loop. Extremely unlikely imo.
const isRequestLoop = (incomingSocket) => _.some([...currentlyForwardingSockets], (outgoingSocket) => normalizeIp(outgoingSocket.localAddress) === normalizeIp(incomingSocket.remoteAddress) &&
    outgoingSocket.remotePort === incomingSocket.localPort);
//# sourceMappingURL=handlers.js.map