"use strict";
/**
 * @module Mockttp
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const typed_error_1 = require("typed-error");
const getFetchPonyfill = require("fetch-ponyfill");
const _ = require("lodash");
const WebSocket = require("universal-websocket-client");
const connectWebSocketStream = require("websocket-stream");
const subscriptions_transport_ws_1 = require("subscriptions-transport-ws");
const { 
/** @hidden */
fetch, 
/** @hidden */
Headers } = getFetchPonyfill();
const mockttp_1 = require("../mockttp");
const mock_rule_1 = require("../rules/mock-rule");
const types_1 = require("../types");
const mocked_endpoint_client_1 = require("./mocked-endpoint-client");
const request_utils_1 = require("../util/request-utils");
const introspection_query_1 = require("./introspection-query");
class ConnectionError extends typed_error_1.TypedError {
}
exports.ConnectionError = ConnectionError;
class RequestError extends typed_error_1.TypedError {
    constructor(message, response) {
        super(message);
        this.response = response;
    }
}
exports.RequestError = RequestError;
class GraphQLError extends RequestError {
    constructor(response, errors) {
        super(`GraphQL request failed, with errors:\n${errors.map((e) => e.message).join('\n')}`, response);
        this.errors = errors;
    }
}
exports.GraphQLError = GraphQLError;
const mergeClientOptions = (options, defaultOptions) => {
    if (!defaultOptions)
        return options;
    if (!options)
        return defaultOptions;
    if (defaultOptions.headers) {
        if (!options.headers) {
            options.headers = defaultOptions.headers;
        }
        else if (options.headers instanceof Headers) {
            _.forEach(defaultOptions.headers, (value, key) => {
                options.headers.append(key, value);
            });
        }
        else if (_.isObject(options.headers)) {
            Object.assign(options.headers, defaultOptions.headers);
        }
    }
    return options;
};
/**
 * A Mockttp implementation, controlling a remote Mockttp standalone server.
 *
 * This starts servers by making requests to the remote standalone server, and exposes
 * methods to directly manage them.
 */
class MockttpClient extends mockttp_1.AbstractMockttp {
    constructor(options = {}) {
        super(_.defaults(options, {
            // Browser clients generally want cors enabled. For other clients, it doesn't hurt.
            // TODO: Maybe detect whether we're in a browser in future
            cors: true,
            standaloneServerUrl: `http://localhost:${types_1.DEFAULT_STANDALONE_PORT}`
        }));
        this.reset = () => __awaiter(this, void 0, void 0, function* () {
            return (yield this.queryMockServer(`mutation Reset {
                    reset
            }`));
        });
        this.addRules = (...rules) => __awaiter(this, void 0, void 0, function* () {
            return this._addRules(rules, false);
        });
        this.setRules = (...rules) => __awaiter(this, void 0, void 0, function* () {
            return this._addRules(rules, true);
        });
        this._addRules = (rules, reset = false) => __awaiter(this, void 0, void 0, function* () {
            // Backward compat: make Add/SetRules work with servers that only define reset & addRule (singular).
            // Adds a small risk of odd behaviour in the gap between reset & all the rules being added, but it
            // should be extremely brief, and no worse than existing behaviour for those server versions.
            if (!this.typeHasField('Mutation', 'addRules')) {
                if (reset)
                    yield this.reset();
                // Sequentially add the rules:
                return rules.reduce((acc, rule) => {
                    return acc.then((endpoints) => __awaiter(this, void 0, void 0, function* () {
                        endpoints.push(yield this._addRule(rule));
                        return endpoints;
                    }));
                }, Promise.resolve([]));
            }
            const requestName = reset ? 'SetRules' : 'AddRules';
            const mutationName = reset ? 'setRules' : 'addRules';
            let ruleIds = (yield this.queryMockServer(`mutation ${requestName}($newRules: [MockRule!]!) {
                rules: ${mutationName}(input: $newRules) {
                    id
                }
            }`, {
                newRules: rules.map((rule) => {
                    const serializedData = mock_rule_1.serializeRuleData(rule, this.mockServerStream);
                    if (!this.typeHasInputField('MockRule', 'id')) {
                        delete serializedData.id;
                    }
                    return serializedData;
                })
            })).rules.map(r => r.id);
            return ruleIds.map(ruleId => new mocked_endpoint_client_1.MockedEndpointClient(ruleId, this.getEndpointData(ruleId)));
        });
        // Exists purely for backward compat with servers that don't support AddRules/SetRules.
        this._addRule = (rule) => __awaiter(this, void 0, void 0, function* () {
            const ruleData = mock_rule_1.serializeRuleData(rule, this.mockServerStream);
            delete ruleData.id; // Old servers don't support sending ids.
            const response = yield this.queryMockServer(`mutation AddRule($newRule: MockRule!) {
                addRule(input: $newRule) {
                    id
                }
            }`, {
                newRule: ruleData
            });
            const ruleId = response.addRule.id;
            return new mocked_endpoint_client_1.MockedEndpointClient(ruleId, this.getEndpointData(ruleId));
        });
        this.getEndpointData = (ruleId) => () => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.queryMockServer(`query GetEndpointData($id: ID!) {
                mockedEndpoint(id: $id) {
                    seenRequests {
                        protocol,
                        method,
                        url,
                        path,
                        hostname,
                        headers,
                        body,
                        ${this.typeHasField('Request', 'timingEvents') ? 'timingEvents' : ''}
                        ${this.typeHasField('Request', 'httpVersion') ? 'httpVersion' : ''}
                    }
                }
            }`, {
                id: ruleId
            });
            const mockedEndpoint = result.mockedEndpoint;
            if (!mockedEndpoint)
                return null;
            mockedEndpoint.seenRequests.forEach((request) => {
                request.body = request_utils_1.buildBodyReader(Buffer.from(request.body, 'base64'), request.headers);
            });
            return mockedEndpoint;
        });
        // Note that 'defaults' above mutates this, so this includes
        // the default parameter values too (and thus the type assertion)
        this.mockServerOptions = _.omit(options, 'client');
        this.mockClientOptions = options.client || {};
    }
    requestFromStandalone(path, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.mockServerOptions.standaloneServerUrl}${path}`;
            let response;
            try {
                response = yield fetch(url, mergeClientOptions(options, this.mockClientOptions));
            }
            catch (e) {
                if (e.code === 'ECONNREFUSED') {
                    throw new ConnectionError(`Failed to connect to standalone server at ${this.mockServerOptions.standaloneServerUrl}`);
                }
                else
                    throw e;
            }
            if (response.status >= 400) {
                let body = yield response.text();
                let jsonBody = null;
                try {
                    jsonBody = JSON.parse(body);
                }
                catch (e) { }
                if (jsonBody && jsonBody.error) {
                    throw new RequestError(jsonBody.error, response);
                }
                else {
                    throw new RequestError(`Request to ${url} failed, with status ${response.status} and response body: ${body}`, response);
                }
            }
            else {
                return response.json();
            }
        });
    }
    openStreamToMockServer(config) {
        const standaloneStreamServer = this.mockServerOptions.standaloneServerUrl.replace(/^http/, 'ws');
        const stream = connectWebSocketStream(`${standaloneStreamServer}/server/${config.port}/stream`, {
            objectMode: true
        });
        return new Promise((resolve, reject) => {
            stream.once('connect', () => resolve(stream));
            stream.once('error', reject);
        });
    }
    requestFromMockServer(path, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.mockServerConfig)
                throw new Error('Not connected to mock server');
            let url = `${this.mockServerOptions.standaloneServerUrl}/server/${this.mockServerConfig.port}${path}`;
            let response = yield fetch(url, mergeClientOptions(options, this.mockClientOptions));
            if (response.status >= 400) {
                throw new RequestError(`Request to ${url} failed, with status ${response.status}`, response);
            }
            else {
                return response;
            }
        });
    }
    queryMockServer(query, variables) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = (yield this.requestFromMockServer('/', {
                    method: 'POST',
                    headers: new Headers({
                        'Content-Type': 'application/json'
                    }),
                    body: JSON.stringify({ query, variables })
                }));
                const { data, errors } = yield response.json();
                if (errors && errors.length) {
                    throw new GraphQLError(response, errors);
                }
                else {
                    return data;
                }
            }
            catch (e) {
                try {
                    let graphQLErrors = (yield e.response.json()).errors;
                    throw new GraphQLError(e, graphQLErrors);
                }
                catch (e2) {
                    // If we fail to get a proper JSON graphql error, just throw the
                    // underlying exception without decoration
                    throw e;
                }
            }
        });
    }
    start(portConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.mockServerConfig)
                throw new Error('Server is already started');
            const path = portConfig ? `/start?port=${JSON.stringify(portConfig)}` : '/start';
            let mockServerConfig = yield this.requestFromStandalone(path, {
                method: 'POST',
                headers: new Headers({
                    'Content-Type': 'application/json'
                }),
                body: JSON.stringify(this.mockServerOptions)
            });
            // Also open a stream connection, for 2-way communication we might need later.
            this.mockServerStream = yield this.openStreamToMockServer(mockServerConfig);
            // We don't persist the config or resolve this promise until everything is set up
            this.mockServerConfig = mockServerConfig;
            // Load the schema on server start, so we can check for feature support
            this.mockServerSchema = (yield this.queryMockServer(introspection_query_1.introspectionQuery)).__schema;
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.mockServerConfig)
                return;
            this.mockServerStream.end();
            yield this.requestFromMockServer('/stop', {
                method: 'POST'
            });
            this.mockServerConfig = this.mockServerStream = undefined;
        });
    }
    typeHasField(typeName, fieldName) {
        const type = _.find(this.mockServerSchema.types, { name: typeName });
        if (!type)
            return false;
        return !!_.find(type.fields, { name: fieldName });
    }
    typeHasInputField(typeName, fieldName) {
        const type = _.find(this.mockServerSchema.types, { name: typeName });
        if (!type)
            return false;
        return !!_.find(type.inputFields, { name: fieldName });
    }
    enableDebug() {
        throw new Error("Client-side debug info not implemented.");
    }
    get url() {
        if (!this.mockServerConfig)
            throw new Error('Cannot get url before server is started');
        return this.mockServerConfig.mockRoot;
    }
    get port() {
        if (!this.mockServerConfig)
            throw new Error('Cannot get port before server is started');
        return this.mockServerConfig.port;
    }
    on(event, callback) {
        const queryResultName = {
            'request-initiated': 'requestInitiated',
            request: 'requestReceived',
            response: 'responseCompleted',
            abort: 'requestAborted',
            tlsClientError: 'failedTlsRequest'
        }[event];
        // Ignore events unknown to either us or the server
        if (!queryResultName ||
            !this.typeHasField('Subscription', queryResultName))
            return Promise.resolve();
        const standaloneStreamServer = this.mockServerOptions.standaloneServerUrl.replace(/^http/, 'ws');
        const url = `${standaloneStreamServer}/server/${this.port}/subscription`;
        const client = new subscriptions_transport_ws_1.SubscriptionClient(url, {
            reconnect: true,
            reconnectionAttempts: 8
        }, WebSocket);
        // Note the typeHasField checks - these are a quick hack for backward compatibility,
        // introspecting the server schema to avoid requesting fields that don't exist on old servers.
        const query = {
            'request-initiated': {
                operationName: 'OnRequestInitiated',
                query: `subscription OnRequestInitiated {
                    ${queryResultName} {
                        id,
                        protocol,
                        method,
                        url,
                        path,
                        hostname,

                        headers,
                        timingEvents,
                        httpVersion,
                        ${this.typeHasField('InitiatedRequest', 'tags') ? 'tags' : ''}
                    }
                }`
            },
            request: {
                operationName: 'OnRequest',
                query: `subscription OnRequest {
                    ${queryResultName} {
                        id,
                        ${this.typeHasField('Request', 'matchedRuleId') ? 'matchedRuleId' : ''}
                        protocol,
                        method,
                        url,
                        path,
                        hostname,

                        headers,
                        body,
                        ${this.typeHasField('Request', 'timingEvents') ? 'timingEvents' : ''}
                        ${this.typeHasField('Request', 'httpVersion') ? 'httpVersion' : ''}
                        ${this.typeHasField('Request', 'tags') ? 'tags' : ''}
                    }
                }`
            },
            response: {
                operationName: 'OnResponse',
                query: `subscription OnResponse {
                    ${queryResultName} {
                        id,
                        statusCode,
                        statusMessage,
                        headers,
                        body,
                        ${this.typeHasField('Response', 'timingEvents') ? 'timingEvents' : ''}
                        ${this.typeHasField('Response', 'tags') ? 'tags' : ''}
                    }
                }`
            },
            abort: {
                operationName: 'OnAbort',
                query: `subscription OnAbort {
                    ${queryResultName} {
                        id,
                        protocol,
                        method,
                        url,
                        path,
                        hostname,

                        headers,
                        body,
                        ${this.typeHasField('Response', 'timingEvents') ? 'timingEvents' : ''}
                        ${this.typeHasField('Response', 'tags') ? 'tags' : ''}
                    }
                }`
            },
            tlsClientError: {
                operationName: 'OnTlsClientError',
                query: `subscription OnTlsClientError {
                    ${queryResultName} {
                        failureCause
                        hostname
                        remoteIpAddress
                        ${this.typeHasField('TlsRequest', 'tags') ? 'tags' : ''}
                    }
                }`
            }
        }[event];
        client.request(query).subscribe({
            next: (value) => {
                if (value.data) {
                    const data = value.data[queryResultName];
                    // TODO: Get a proper graphql client that does all this automatically from the schema itself
                    if (data.headers) {
                        data.headers = JSON.parse(data.headers);
                    }
                    if (data.timingEvents) {
                        data.timingEvents = JSON.parse(data.timingEvents);
                    }
                    else if (event !== 'tlsClientError') {
                        data.timingEvents = {}; // For backward compat
                    }
                    if (!data.tags)
                        data.tags = [];
                    if (data.body) {
                        data.body = request_utils_1.buildBodyReader(Buffer.from(data.body, 'base64'), data.headers);
                    }
                    callback(data);
                }
                else if (value.errors) {
                    console.error('Error in subscription', value.errors);
                }
            },
            error: (e) => this.debug && console.warn('Error in remote subscription:', e)
        });
        return new Promise((resolve, reject) => {
            client.onConnected(() => {
                if (this.debug)
                    console.log("Subscription connected");
                resolve();
            });
            client.onDisconnected(() => {
                if (this.debug)
                    console.warn("Subscription disconnected");
                reject();
            });
            client.onError((e) => {
                if (this.debug)
                    console.error("Subscription error", e);
            });
            client.onReconnecting(() => console.warn(`Reconnecting ${event} subscription`));
        });
    }
}
exports.default = MockttpClient;
//# sourceMappingURL=mockttp-client.js.map